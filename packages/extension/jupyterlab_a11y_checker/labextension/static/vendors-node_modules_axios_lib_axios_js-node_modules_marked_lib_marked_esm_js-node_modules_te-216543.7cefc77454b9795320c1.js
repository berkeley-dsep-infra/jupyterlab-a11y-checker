(self['webpackChunkjupyterlab_a11y_checker'] =
  self['webpackChunkjupyterlab_a11y_checker'] || []).push([
  [
    'vendors-node_modules_axios_lib_axios_js-node_modules_marked_lib_marked_esm_js-node_modules_te-216543'
  ],
  {
    /***/ '../../node_modules/axios/lib/adapters/adapters.js':
      /*!*********************************************************!*\
  !*** ../../node_modules/axios/lib/adapters/adapters.js ***!
  \*********************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__
          /* harmony export */
        });
        /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ =
          __webpack_require__(
            /*! ../utils.js */ '../../node_modules/axios/lib/utils.js'
          );
        /* harmony import */ var _http_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ./http.js */ '../../node_modules/axios/lib/helpers/null.js'
          );
        /* harmony import */ var _xhr_js__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! ./xhr.js */ '../../node_modules/axios/lib/adapters/xhr.js'
          );
        /* harmony import */ var _fetch_js__WEBPACK_IMPORTED_MODULE_2__ =
          __webpack_require__(
            /*! ./fetch.js */ '../../node_modules/axios/lib/adapters/fetch.js'
          );
        /* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_4__ =
          __webpack_require__(
            /*! ../core/AxiosError.js */ '../../node_modules/axios/lib/core/AxiosError.js'
          );

        const knownAdapters = {
          http: _http_js__WEBPACK_IMPORTED_MODULE_0__['default'],
          xhr: _xhr_js__WEBPACK_IMPORTED_MODULE_1__['default'],
          fetch: _fetch_js__WEBPACK_IMPORTED_MODULE_2__['default']
        };

        _utils_js__WEBPACK_IMPORTED_MODULE_3__['default'].forEach(
          knownAdapters,
          (fn, value) => {
            if (fn) {
              try {
                Object.defineProperty(fn, 'name', { value });
              } catch (e) {
                // eslint-disable-next-line no-empty
              }
              Object.defineProperty(fn, 'adapterName', { value });
            }
          }
        );

        const renderReason = reason => `- ${reason}`;

        const isResolvedHandle = adapter =>
          _utils_js__WEBPACK_IMPORTED_MODULE_3__['default'].isFunction(
            adapter
          ) ||
          adapter === null ||
          adapter === false;

        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = {
          getAdapter: adapters => {
            adapters = _utils_js__WEBPACK_IMPORTED_MODULE_3__[
              'default'
            ].isArray(adapters)
              ? adapters
              : [adapters];

            const { length } = adapters;
            let nameOrAdapter;
            let adapter;

            const rejectedReasons = {};

            for (let i = 0; i < length; i++) {
              nameOrAdapter = adapters[i];
              let id;

              adapter = nameOrAdapter;

              if (!isResolvedHandle(nameOrAdapter)) {
                adapter =
                  knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];

                if (adapter === undefined) {
                  throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_4__[
                    'default'
                  ](`Unknown adapter '${id}'`);
                }
              }

              if (adapter) {
                break;
              }

              rejectedReasons[id || '#' + i] = adapter;
            }

            if (!adapter) {
              const reasons = Object.entries(rejectedReasons).map(
                ([id, state]) =>
                  `adapter ${id} ` +
                  (state === false
                    ? 'is not supported by the environment'
                    : 'is not available in the build')
              );

              let s = length
                ? reasons.length > 1
                  ? 'since :\n' + reasons.map(renderReason).join('\n')
                  : ' ' + renderReason(reasons[0])
                : 'as no adapter specified';

              throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_4__[
                'default'
              ](
                `There is no suitable adapter to dispatch the request ` + s,
                'ERR_NOT_SUPPORT'
              );
            }

            return adapter;
          },
          adapters: knownAdapters
        };

        /***/
      },

    /***/ '../../node_modules/axios/lib/adapters/fetch.js':
      /*!******************************************************!*\
  !*** ../../node_modules/axios/lib/adapters/fetch.js ***!
  \******************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__
          /* harmony export */
        });
        /* harmony import */ var _platform_index_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ../platform/index.js */ '../../node_modules/axios/lib/platform/index.js'
          );
        /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! ../utils.js */ '../../node_modules/axios/lib/utils.js'
          );
        /* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__ =
          __webpack_require__(
            /*! ../core/AxiosError.js */ '../../node_modules/axios/lib/core/AxiosError.js'
          );
        /* harmony import */ var _helpers_composeSignals_js__WEBPACK_IMPORTED_MODULE_4__ =
          __webpack_require__(
            /*! ../helpers/composeSignals.js */ '../../node_modules/axios/lib/helpers/composeSignals.js'
          );
        /* harmony import */ var _helpers_trackStream_js__WEBPACK_IMPORTED_MODULE_6__ =
          __webpack_require__(
            /*! ../helpers/trackStream.js */ '../../node_modules/axios/lib/helpers/trackStream.js'
          );
        /* harmony import */ var _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_8__ =
          __webpack_require__(
            /*! ../core/AxiosHeaders.js */ '../../node_modules/axios/lib/core/AxiosHeaders.js'
          );
        /* harmony import */ var _helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_5__ =
          __webpack_require__(
            /*! ../helpers/progressEventReducer.js */ '../../node_modules/axios/lib/helpers/progressEventReducer.js'
          );
        /* harmony import */ var _helpers_resolveConfig_js__WEBPACK_IMPORTED_MODULE_3__ =
          __webpack_require__(
            /*! ../helpers/resolveConfig.js */ '../../node_modules/axios/lib/helpers/resolveConfig.js'
          );
        /* harmony import */ var _core_settle_js__WEBPACK_IMPORTED_MODULE_7__ =
          __webpack_require__(
            /*! ../core/settle.js */ '../../node_modules/axios/lib/core/settle.js'
          );

        const isFetchSupported =
          typeof fetch === 'function' &&
          typeof Request === 'function' &&
          typeof Response === 'function';
        const isReadableStreamSupported =
          isFetchSupported && typeof ReadableStream === 'function';

        // used only inside the fetch adapter
        const encodeText =
          isFetchSupported &&
          (typeof TextEncoder === 'function'
            ? (
                encoder => str =>
                  encoder.encode(str)
              )(new TextEncoder())
            : async str =>
                new Uint8Array(await new Response(str).arrayBuffer()));

        const test = (fn, ...args) => {
          try {
            return !!fn(...args);
          } catch (e) {
            return false;
          }
        };

        const supportsRequestStream =
          isReadableStreamSupported &&
          test(() => {
            let duplexAccessed = false;

            const hasContentType = new Request(
              _platform_index_js__WEBPACK_IMPORTED_MODULE_0__['default'].origin,
              {
                body: new ReadableStream(),
                method: 'POST',
                get duplex() {
                  duplexAccessed = true;
                  return 'half';
                }
              }
            ).headers.has('Content-Type');

            return duplexAccessed && !hasContentType;
          });

        const DEFAULT_CHUNK_SIZE = 64 * 1024;

        const supportsResponseStream =
          isReadableStreamSupported &&
          test(() =>
            _utils_js__WEBPACK_IMPORTED_MODULE_1__['default'].isReadableStream(
              new Response('').body
            )
          );

        const resolvers = {
          stream: supportsResponseStream && (res => res.body)
        };

        isFetchSupported &&
          (res => {
            ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach(
              type => {
                !resolvers[type] &&
                  (resolvers[type] = _utils_js__WEBPACK_IMPORTED_MODULE_1__[
                    'default'
                  ].isFunction(res[type])
                    ? res => res[type]()
                    : (_, config) => {
                        throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__[
                          'default'
                        ](
                          `Response type '${type}' is not supported`,
                          _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__[
                            'default'
                          ].ERR_NOT_SUPPORT,
                          config
                        );
                      });
              }
            );
          })(new Response());

        const getBodyLength = async body => {
          if (body == null) {
            return 0;
          }

          if (_utils_js__WEBPACK_IMPORTED_MODULE_1__['default'].isBlob(body)) {
            return body.size;
          }

          if (
            _utils_js__WEBPACK_IMPORTED_MODULE_1__[
              'default'
            ].isSpecCompliantForm(body)
          ) {
            const _request = new Request(
              _platform_index_js__WEBPACK_IMPORTED_MODULE_0__['default'].origin,
              {
                method: 'POST',
                body
              }
            );
            return (await _request.arrayBuffer()).byteLength;
          }

          if (
            _utils_js__WEBPACK_IMPORTED_MODULE_1__['default'].isArrayBufferView(
              body
            ) ||
            _utils_js__WEBPACK_IMPORTED_MODULE_1__['default'].isArrayBuffer(
              body
            )
          ) {
            return body.byteLength;
          }

          if (
            _utils_js__WEBPACK_IMPORTED_MODULE_1__['default'].isURLSearchParams(
              body
            )
          ) {
            body = body + '';
          }

          if (
            _utils_js__WEBPACK_IMPORTED_MODULE_1__['default'].isString(body)
          ) {
            return (await encodeText(body)).byteLength;
          }
        };

        const resolveBodyLength = async (headers, body) => {
          const length = _utils_js__WEBPACK_IMPORTED_MODULE_1__[
            'default'
          ].toFiniteNumber(headers.getContentLength());

          return length == null ? getBodyLength(body) : length;
        };

        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          isFetchSupported &&
          (async config => {
            let {
              url,
              method,
              data,
              signal,
              cancelToken,
              timeout,
              onDownloadProgress,
              onUploadProgress,
              responseType,
              headers,
              withCredentials = 'same-origin',
              fetchOptions
            } = (0,
            _helpers_resolveConfig_js__WEBPACK_IMPORTED_MODULE_3__['default'])(
              config
            );

            responseType = responseType
              ? (responseType + '').toLowerCase()
              : 'text';

            let composedSignal = (0,
            _helpers_composeSignals_js__WEBPACK_IMPORTED_MODULE_4__['default'])(
              [signal, cancelToken && cancelToken.toAbortSignal()],
              timeout
            );

            let request;

            const unsubscribe =
              composedSignal &&
              composedSignal.unsubscribe &&
              (() => {
                composedSignal.unsubscribe();
              });

            let requestContentLength;

            try {
              if (
                onUploadProgress &&
                supportsRequestStream &&
                method !== 'get' &&
                method !== 'head' &&
                (requestContentLength = await resolveBodyLength(
                  headers,
                  data
                )) !== 0
              ) {
                let _request = new Request(url, {
                  method: 'POST',
                  body: data,
                  duplex: 'half'
                });

                let contentTypeHeader;

                if (
                  _utils_js__WEBPACK_IMPORTED_MODULE_1__['default'].isFormData(
                    data
                  ) &&
                  (contentTypeHeader = _request.headers.get('content-type'))
                ) {
                  headers.setContentType(contentTypeHeader);
                }

                if (_request.body) {
                  const [onProgress, flush] = (0,
                  _helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_5__.progressEventDecorator)(
                    requestContentLength,
                    (0,
                    _helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_5__.progressEventReducer)(
                      (0,
                      _helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_5__.asyncDecorator)(
                        onUploadProgress
                      )
                    )
                  );

                  data = (0,
                  _helpers_trackStream_js__WEBPACK_IMPORTED_MODULE_6__.trackStream)(
                    _request.body,
                    DEFAULT_CHUNK_SIZE,
                    onProgress,
                    flush
                  );
                }
              }

              if (
                !_utils_js__WEBPACK_IMPORTED_MODULE_1__['default'].isString(
                  withCredentials
                )
              ) {
                withCredentials = withCredentials ? 'include' : 'omit';
              }

              // Cloudflare Workers throws when credentials are defined
              // see https://github.com/cloudflare/workerd/issues/902
              const isCredentialsSupported = 'credentials' in Request.prototype;
              request = new Request(url, {
                ...fetchOptions,
                signal: composedSignal,
                method: method.toUpperCase(),
                headers: headers.normalize().toJSON(),
                body: data,
                duplex: 'half',
                credentials: isCredentialsSupported
                  ? withCredentials
                  : undefined
              });

              let response = await fetch(request);

              const isStreamResponse =
                supportsResponseStream &&
                (responseType === 'stream' || responseType === 'response');

              if (
                supportsResponseStream &&
                (onDownloadProgress || (isStreamResponse && unsubscribe))
              ) {
                const options = {};

                ['status', 'statusText', 'headers'].forEach(prop => {
                  options[prop] = response[prop];
                });

                const responseContentLength =
                  _utils_js__WEBPACK_IMPORTED_MODULE_1__[
                    'default'
                  ].toFiniteNumber(response.headers.get('content-length'));

                const [onProgress, flush] =
                  (onDownloadProgress &&
                    (0,
                    _helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_5__.progressEventDecorator)(
                      responseContentLength,
                      (0,
                      _helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_5__.progressEventReducer)(
                        (0,
                        _helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_5__.asyncDecorator)(
                          onDownloadProgress
                        ),
                        true
                      )
                    )) ||
                  [];

                response = new Response(
                  (0,
                  _helpers_trackStream_js__WEBPACK_IMPORTED_MODULE_6__.trackStream)(
                    response.body,
                    DEFAULT_CHUNK_SIZE,
                    onProgress,
                    () => {
                      flush && flush();
                      unsubscribe && unsubscribe();
                    }
                  ),
                  options
                );
              }

              responseType = responseType || 'text';

              let responseData = await resolvers[
                _utils_js__WEBPACK_IMPORTED_MODULE_1__['default'].findKey(
                  resolvers,
                  responseType
                ) || 'text'
              ](response, config);

              !isStreamResponse && unsubscribe && unsubscribe();

              return await new Promise((resolve, reject) => {
                (0, _core_settle_js__WEBPACK_IMPORTED_MODULE_7__['default'])(
                  resolve,
                  reject,
                  {
                    data: responseData,
                    headers: _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_8__[
                      'default'
                    ].from(response.headers),
                    status: response.status,
                    statusText: response.statusText,
                    config,
                    request
                  }
                );
              });
            } catch (err) {
              unsubscribe && unsubscribe();

              if (
                err &&
                err.name === 'TypeError' &&
                /fetch/i.test(err.message)
              ) {
                throw Object.assign(
                  new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__[
                    'default'
                  ](
                    'Network Error',
                    _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__['default']
                      .ERR_NETWORK,
                    config,
                    request
                  ),
                  {
                    cause: err.cause || err
                  }
                );
              }

              throw _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__[
                'default'
              ].from(err, err && err.code, config, request);
            }
          });

        /***/
      },

    /***/ '../../node_modules/axios/lib/adapters/xhr.js':
      /*!****************************************************!*\
  !*** ../../node_modules/axios/lib/adapters/xhr.js ***!
  \****************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__
          /* harmony export */
        });
        /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_5__ =
          __webpack_require__(
            /*! ./../utils.js */ '../../node_modules/axios/lib/utils.js'
          );
        /* harmony import */ var _core_settle_js__WEBPACK_IMPORTED_MODULE_2__ =
          __webpack_require__(
            /*! ./../core/settle.js */ '../../node_modules/axios/lib/core/settle.js'
          );
        /* harmony import */ var _defaults_transitional_js__WEBPACK_IMPORTED_MODULE_4__ =
          __webpack_require__(
            /*! ../defaults/transitional.js */ '../../node_modules/axios/lib/defaults/transitional.js'
          );
        /* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__ =
          __webpack_require__(
            /*! ../core/AxiosError.js */ '../../node_modules/axios/lib/core/AxiosError.js'
          );
        /* harmony import */ var _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_7__ =
          __webpack_require__(
            /*! ../cancel/CanceledError.js */ '../../node_modules/axios/lib/cancel/CanceledError.js'
          );
        /* harmony import */ var _helpers_parseProtocol_js__WEBPACK_IMPORTED_MODULE_8__ =
          __webpack_require__(
            /*! ../helpers/parseProtocol.js */ '../../node_modules/axios/lib/helpers/parseProtocol.js'
          );
        /* harmony import */ var _platform_index_js__WEBPACK_IMPORTED_MODULE_9__ =
          __webpack_require__(
            /*! ../platform/index.js */ '../../node_modules/axios/lib/platform/index.js'
          );
        /* harmony import */ var _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! ../core/AxiosHeaders.js */ '../../node_modules/axios/lib/core/AxiosHeaders.js'
          );
        /* harmony import */ var _helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_6__ =
          __webpack_require__(
            /*! ../helpers/progressEventReducer.js */ '../../node_modules/axios/lib/helpers/progressEventReducer.js'
          );
        /* harmony import */ var _helpers_resolveConfig_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ../helpers/resolveConfig.js */ '../../node_modules/axios/lib/helpers/resolveConfig.js'
          );

        const isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';

        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          isXHRAdapterSupported &&
          function (config) {
            return new Promise(function dispatchXhrRequest(resolve, reject) {
              const _config = (0,
              _helpers_resolveConfig_js__WEBPACK_IMPORTED_MODULE_0__[
                'default'
              ])(config);
              let requestData = _config.data;
              const requestHeaders =
                _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__['default']
                  .from(_config.headers)
                  .normalize();
              let { responseType, onUploadProgress, onDownloadProgress } =
                _config;
              let onCanceled;
              let uploadThrottled, downloadThrottled;
              let flushUpload, flushDownload;

              function done() {
                flushUpload && flushUpload(); // flush events
                flushDownload && flushDownload(); // flush events

                _config.cancelToken &&
                  _config.cancelToken.unsubscribe(onCanceled);

                _config.signal &&
                  _config.signal.removeEventListener('abort', onCanceled);
              }

              let request = new XMLHttpRequest();

              request.open(_config.method.toUpperCase(), _config.url, true);

              // Set the request timeout in MS
              request.timeout = _config.timeout;

              function onloadend() {
                if (!request) {
                  return;
                }
                // Prepare the response
                const responseHeaders =
                  _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__[
                    'default'
                  ].from(
                    'getAllResponseHeaders' in request &&
                      request.getAllResponseHeaders()
                  );
                const responseData =
                  !responseType ||
                  responseType === 'text' ||
                  responseType === 'json'
                    ? request.responseText
                    : request.response;
                const response = {
                  data: responseData,
                  status: request.status,
                  statusText: request.statusText,
                  headers: responseHeaders,
                  config,
                  request
                };

                (0, _core_settle_js__WEBPACK_IMPORTED_MODULE_2__['default'])(
                  function _resolve(value) {
                    resolve(value);
                    done();
                  },
                  function _reject(err) {
                    reject(err);
                    done();
                  },
                  response
                );

                // Clean up request
                request = null;
              }

              if ('onloadend' in request) {
                // Use onloadend if available
                request.onloadend = onloadend;
              } else {
                // Listen for ready state to emulate onloadend
                request.onreadystatechange = function handleLoad() {
                  if (!request || request.readyState !== 4) {
                    return;
                  }

                  // The request errored out and we didn't get a response, this will be
                  // handled by onerror instead
                  // With one exception: request that using file: protocol, most browsers
                  // will return status as 0 even though it's a successful request
                  if (
                    request.status === 0 &&
                    !(
                      request.responseURL &&
                      request.responseURL.indexOf('file:') === 0
                    )
                  ) {
                    return;
                  }
                  // readystate handler is calling before onerror or ontimeout handlers,
                  // so we should call onloadend on the next 'tick'
                  setTimeout(onloadend);
                };
              }

              // Handle browser request cancellation (as opposed to a manual cancellation)
              request.onabort = function handleAbort() {
                if (!request) {
                  return;
                }

                reject(
                  new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__[
                    'default'
                  ](
                    'Request aborted',
                    _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__['default']
                      .ECONNABORTED,
                    config,
                    request
                  )
                );

                // Clean up request
                request = null;
              };

              // Handle low level network errors
              request.onerror = function handleError() {
                // Real errors are hidden from us by the browser
                // onerror should only fire if it's a network error
                reject(
                  new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__[
                    'default'
                  ](
                    'Network Error',
                    _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__['default']
                      .ERR_NETWORK,
                    config,
                    request
                  )
                );

                // Clean up request
                request = null;
              };

              // Handle timeout
              request.ontimeout = function handleTimeout() {
                let timeoutErrorMessage = _config.timeout
                  ? 'timeout of ' + _config.timeout + 'ms exceeded'
                  : 'timeout exceeded';
                const transitional =
                  _config.transitional ||
                  _defaults_transitional_js__WEBPACK_IMPORTED_MODULE_4__[
                    'default'
                  ];
                if (_config.timeoutErrorMessage) {
                  timeoutErrorMessage = _config.timeoutErrorMessage;
                }
                reject(
                  new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__[
                    'default'
                  ](
                    timeoutErrorMessage,
                    transitional.clarifyTimeoutError
                      ? _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__[
                          'default'
                        ].ETIMEDOUT
                      : _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__[
                          'default'
                        ].ECONNABORTED,
                    config,
                    request
                  )
                );

                // Clean up request
                request = null;
              };

              // Remove Content-Type if data is undefined
              requestData === undefined && requestHeaders.setContentType(null);

              // Add headers to the request
              if ('setRequestHeader' in request) {
                _utils_js__WEBPACK_IMPORTED_MODULE_5__['default'].forEach(
                  requestHeaders.toJSON(),
                  function setRequestHeader(val, key) {
                    request.setRequestHeader(key, val);
                  }
                );
              }

              // Add withCredentials to request if needed
              if (
                !_utils_js__WEBPACK_IMPORTED_MODULE_5__['default'].isUndefined(
                  _config.withCredentials
                )
              ) {
                request.withCredentials = !!_config.withCredentials;
              }

              // Add responseType to request if needed
              if (responseType && responseType !== 'json') {
                request.responseType = _config.responseType;
              }

              // Handle progress if needed
              if (onDownloadProgress) {
                [downloadThrottled, flushDownload] = (0,
                _helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_6__.progressEventReducer)(
                  onDownloadProgress,
                  true
                );
                request.addEventListener('progress', downloadThrottled);
              }

              // Not all browsers support upload events
              if (onUploadProgress && request.upload) {
                [uploadThrottled, flushUpload] = (0,
                _helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_6__.progressEventReducer)(
                  onUploadProgress
                );

                request.upload.addEventListener('progress', uploadThrottled);

                request.upload.addEventListener('loadend', flushUpload);
              }

              if (_config.cancelToken || _config.signal) {
                // Handle cancellation
                // eslint-disable-next-line func-names
                onCanceled = cancel => {
                  if (!request) {
                    return;
                  }
                  reject(
                    !cancel || cancel.type
                      ? new _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_7__[
                          'default'
                        ](null, config, request)
                      : cancel
                  );
                  request.abort();
                  request = null;
                };

                _config.cancelToken &&
                  _config.cancelToken.subscribe(onCanceled);
                if (_config.signal) {
                  _config.signal.aborted
                    ? onCanceled()
                    : _config.signal.addEventListener('abort', onCanceled);
                }
              }

              const protocol = (0,
              _helpers_parseProtocol_js__WEBPACK_IMPORTED_MODULE_8__[
                'default'
              ])(_config.url);

              if (
                protocol &&
                _platform_index_js__WEBPACK_IMPORTED_MODULE_9__[
                  'default'
                ].protocols.indexOf(protocol) === -1
              ) {
                reject(
                  new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__[
                    'default'
                  ](
                    'Unsupported protocol ' + protocol + ':',
                    _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__['default']
                      .ERR_BAD_REQUEST,
                    config
                  )
                );
                return;
              }

              // Send the request
              request.send(requestData || null);
            });
          };

        /***/
      },

    /***/ '../../node_modules/axios/lib/axios.js':
      /*!*********************************************!*\
  !*** ../../node_modules/axios/lib/axios.js ***!
  \*********************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__
          /* harmony export */
        });
        /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ =
          __webpack_require__(
            /*! ./utils.js */ '../../node_modules/axios/lib/utils.js'
          );
        /* harmony import */ var _helpers_bind_js__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! ./helpers/bind.js */ '../../node_modules/axios/lib/helpers/bind.js'
          );
        /* harmony import */ var _core_Axios_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ./core/Axios.js */ '../../node_modules/axios/lib/core/Axios.js'
          );
        /* harmony import */ var _core_mergeConfig_js__WEBPACK_IMPORTED_MODULE_3__ =
          __webpack_require__(
            /*! ./core/mergeConfig.js */ '../../node_modules/axios/lib/core/mergeConfig.js'
          );
        /* harmony import */ var _defaults_index_js__WEBPACK_IMPORTED_MODULE_4__ =
          __webpack_require__(
            /*! ./defaults/index.js */ '../../node_modules/axios/lib/defaults/index.js'
          );
        /* harmony import */ var _helpers_formDataToJSON_js__WEBPACK_IMPORTED_MODULE_14__ =
          __webpack_require__(
            /*! ./helpers/formDataToJSON.js */ '../../node_modules/axios/lib/helpers/formDataToJSON.js'
          );
        /* harmony import */ var _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_5__ =
          __webpack_require__(
            /*! ./cancel/CanceledError.js */ '../../node_modules/axios/lib/cancel/CanceledError.js'
          );
        /* harmony import */ var _cancel_CancelToken_js__WEBPACK_IMPORTED_MODULE_6__ =
          __webpack_require__(
            /*! ./cancel/CancelToken.js */ '../../node_modules/axios/lib/cancel/CancelToken.js'
          );
        /* harmony import */ var _cancel_isCancel_js__WEBPACK_IMPORTED_MODULE_7__ =
          __webpack_require__(
            /*! ./cancel/isCancel.js */ '../../node_modules/axios/lib/cancel/isCancel.js'
          );
        /* harmony import */ var _env_data_js__WEBPACK_IMPORTED_MODULE_8__ =
          __webpack_require__(
            /*! ./env/data.js */ '../../node_modules/axios/lib/env/data.js'
          );
        /* harmony import */ var _helpers_toFormData_js__WEBPACK_IMPORTED_MODULE_9__ =
          __webpack_require__(
            /*! ./helpers/toFormData.js */ '../../node_modules/axios/lib/helpers/toFormData.js'
          );
        /* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_10__ =
          __webpack_require__(
            /*! ./core/AxiosError.js */ '../../node_modules/axios/lib/core/AxiosError.js'
          );
        /* harmony import */ var _helpers_spread_js__WEBPACK_IMPORTED_MODULE_11__ =
          __webpack_require__(
            /*! ./helpers/spread.js */ '../../node_modules/axios/lib/helpers/spread.js'
          );
        /* harmony import */ var _helpers_isAxiosError_js__WEBPACK_IMPORTED_MODULE_12__ =
          __webpack_require__(
            /*! ./helpers/isAxiosError.js */ '../../node_modules/axios/lib/helpers/isAxiosError.js'
          );
        /* harmony import */ var _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_13__ =
          __webpack_require__(
            /*! ./core/AxiosHeaders.js */ '../../node_modules/axios/lib/core/AxiosHeaders.js'
          );
        /* harmony import */ var _adapters_adapters_js__WEBPACK_IMPORTED_MODULE_15__ =
          __webpack_require__(
            /*! ./adapters/adapters.js */ '../../node_modules/axios/lib/adapters/adapters.js'
          );
        /* harmony import */ var _helpers_HttpStatusCode_js__WEBPACK_IMPORTED_MODULE_16__ =
          __webpack_require__(
            /*! ./helpers/HttpStatusCode.js */ '../../node_modules/axios/lib/helpers/HttpStatusCode.js'
          );

        /**
         * Create an instance of Axios
         *
         * @param {Object} defaultConfig The default config for the instance
         *
         * @returns {Axios} A new instance of Axios
         */
        function createInstance(defaultConfig) {
          const context = new _core_Axios_js__WEBPACK_IMPORTED_MODULE_0__[
            'default'
          ](defaultConfig);
          const instance = (0,
          _helpers_bind_js__WEBPACK_IMPORTED_MODULE_1__['default'])(
            _core_Axios_js__WEBPACK_IMPORTED_MODULE_0__['default'].prototype
              .request,
            context
          );

          // Copy axios.prototype to instance
          _utils_js__WEBPACK_IMPORTED_MODULE_2__['default'].extend(
            instance,
            _core_Axios_js__WEBPACK_IMPORTED_MODULE_0__['default'].prototype,
            context,
            { allOwnKeys: true }
          );

          // Copy context to instance
          _utils_js__WEBPACK_IMPORTED_MODULE_2__['default'].extend(
            instance,
            context,
            null,
            { allOwnKeys: true }
          );

          // Factory for creating new instances
          instance.create = function create(instanceConfig) {
            return createInstance(
              (0, _core_mergeConfig_js__WEBPACK_IMPORTED_MODULE_3__['default'])(
                defaultConfig,
                instanceConfig
              )
            );
          };

          return instance;
        }

        // Create the default instance to be exported
        const axios = createInstance(
          _defaults_index_js__WEBPACK_IMPORTED_MODULE_4__['default']
        );

        // Expose Axios class to allow class inheritance
        axios.Axios = _core_Axios_js__WEBPACK_IMPORTED_MODULE_0__['default'];

        // Expose Cancel & CancelToken
        axios.CanceledError =
          _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_5__['default'];
        axios.CancelToken =
          _cancel_CancelToken_js__WEBPACK_IMPORTED_MODULE_6__['default'];
        axios.isCancel =
          _cancel_isCancel_js__WEBPACK_IMPORTED_MODULE_7__['default'];
        axios.VERSION = _env_data_js__WEBPACK_IMPORTED_MODULE_8__.VERSION;
        axios.toFormData =
          _helpers_toFormData_js__WEBPACK_IMPORTED_MODULE_9__['default'];

        // Expose AxiosError class
        axios.AxiosError =
          _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_10__['default'];

        // alias for CanceledError for backward compatibility
        axios.Cancel = axios.CanceledError;

        // Expose all/spread
        axios.all = function all(promises) {
          return Promise.all(promises);
        };

        axios.spread =
          _helpers_spread_js__WEBPACK_IMPORTED_MODULE_11__['default'];

        // Expose isAxiosError
        axios.isAxiosError =
          _helpers_isAxiosError_js__WEBPACK_IMPORTED_MODULE_12__['default'];

        // Expose mergeConfig
        axios.mergeConfig =
          _core_mergeConfig_js__WEBPACK_IMPORTED_MODULE_3__['default'];

        axios.AxiosHeaders =
          _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_13__['default'];

        axios.formToJSON = thing =>
          (0,
          _helpers_formDataToJSON_js__WEBPACK_IMPORTED_MODULE_14__['default'])(
            _utils_js__WEBPACK_IMPORTED_MODULE_2__['default'].isHTMLForm(thing)
              ? new FormData(thing)
              : thing
          );

        axios.getAdapter =
          _adapters_adapters_js__WEBPACK_IMPORTED_MODULE_15__[
            'default'
          ].getAdapter;

        axios.HttpStatusCode =
          _helpers_HttpStatusCode_js__WEBPACK_IMPORTED_MODULE_16__['default'];

        axios.default = axios;

        // this module should only have a default export
        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = axios;

        /***/
      },

    /***/ '../../node_modules/axios/lib/cancel/CancelToken.js':
      /*!**********************************************************!*\
  !*** ../../node_modules/axios/lib/cancel/CancelToken.js ***!
  \**********************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__
          /* harmony export */
        });
        /* harmony import */ var _CanceledError_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ./CanceledError.js */ '../../node_modules/axios/lib/cancel/CanceledError.js'
          );

        /**
         * A `CancelToken` is an object that can be used to request cancellation of an operation.
         *
         * @param {Function} executor The executor function.
         *
         * @returns {CancelToken}
         */
        class CancelToken {
          constructor(executor) {
            if (typeof executor !== 'function') {
              throw new TypeError('executor must be a function.');
            }

            let resolvePromise;

            this.promise = new Promise(function promiseExecutor(resolve) {
              resolvePromise = resolve;
            });

            const token = this;

            // eslint-disable-next-line func-names
            this.promise.then(cancel => {
              if (!token._listeners) return;

              let i = token._listeners.length;

              while (i-- > 0) {
                token._listeners[i](cancel);
              }
              token._listeners = null;
            });

            // eslint-disable-next-line func-names
            this.promise.then = onfulfilled => {
              let _resolve;
              // eslint-disable-next-line func-names
              const promise = new Promise(resolve => {
                token.subscribe(resolve);
                _resolve = resolve;
              }).then(onfulfilled);

              promise.cancel = function reject() {
                token.unsubscribe(_resolve);
              };

              return promise;
            };

            executor(function cancel(message, config, request) {
              if (token.reason) {
                // Cancellation has already been requested
                return;
              }

              token.reason = new _CanceledError_js__WEBPACK_IMPORTED_MODULE_0__[
                'default'
              ](message, config, request);
              resolvePromise(token.reason);
            });
          }

          /**
           * Throws a `CanceledError` if cancellation has been requested.
           */
          throwIfRequested() {
            if (this.reason) {
              throw this.reason;
            }
          }

          /**
           * Subscribe to the cancel signal
           */

          subscribe(listener) {
            if (this.reason) {
              listener(this.reason);
              return;
            }

            if (this._listeners) {
              this._listeners.push(listener);
            } else {
              this._listeners = [listener];
            }
          }

          /**
           * Unsubscribe from the cancel signal
           */

          unsubscribe(listener) {
            if (!this._listeners) {
              return;
            }
            const index = this._listeners.indexOf(listener);
            if (index !== -1) {
              this._listeners.splice(index, 1);
            }
          }

          toAbortSignal() {
            const controller = new AbortController();

            const abort = err => {
              controller.abort(err);
            };

            this.subscribe(abort);

            controller.signal.unsubscribe = () => this.unsubscribe(abort);

            return controller.signal;
          }

          /**
           * Returns an object that contains a new `CancelToken` and a function that, when called,
           * cancels the `CancelToken`.
           */
          static source() {
            let cancel;
            const token = new CancelToken(function executor(c) {
              cancel = c;
            });
            return {
              token,
              cancel
            };
          }
        }

        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          CancelToken;

        /***/
      },

    /***/ '../../node_modules/axios/lib/cancel/CanceledError.js':
      /*!************************************************************!*\
  !*** ../../node_modules/axios/lib/cancel/CanceledError.js ***!
  \************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__
          /* harmony export */
        });
        /* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ../core/AxiosError.js */ '../../node_modules/axios/lib/core/AxiosError.js'
          );
        /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! ../utils.js */ '../../node_modules/axios/lib/utils.js'
          );

        /**
         * A `CanceledError` is an object that is thrown when an operation is canceled.
         *
         * @param {string=} message The message.
         * @param {Object=} config The config.
         * @param {Object=} request The request.
         *
         * @returns {CanceledError} The created error.
         */
        function CanceledError(message, config, request) {
          // eslint-disable-next-line no-eq-null,eqeqeq
          _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_0__['default'].call(
            this,
            message == null ? 'canceled' : message,
            _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_0__['default']
              .ERR_CANCELED,
            config,
            request
          );
          this.name = 'CanceledError';
        }

        _utils_js__WEBPACK_IMPORTED_MODULE_1__['default'].inherits(
          CanceledError,
          _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_0__['default'],
          {
            __CANCEL__: true
          }
        );

        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          CanceledError;

        /***/
      },

    /***/ '../../node_modules/axios/lib/cancel/isCancel.js':
      /*!*******************************************************!*\
  !*** ../../node_modules/axios/lib/cancel/isCancel.js ***!
  \*******************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => /* binding */ isCancel
          /* harmony export */
        });

        function isCancel(value) {
          return !!(value && value.__CANCEL__);
        }

        /***/
      },

    /***/ '../../node_modules/axios/lib/core/Axios.js':
      /*!**************************************************!*\
  !*** ../../node_modules/axios/lib/core/Axios.js ***!
  \**************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__
          /* harmony export */
        });
        /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ =
          __webpack_require__(
            /*! ./../utils.js */ '../../node_modules/axios/lib/utils.js'
          );
        /* harmony import */ var _helpers_buildURL_js__WEBPACK_IMPORTED_MODULE_7__ =
          __webpack_require__(
            /*! ../helpers/buildURL.js */ '../../node_modules/axios/lib/helpers/buildURL.js'
          );
        /* harmony import */ var _InterceptorManager_js__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! ./InterceptorManager.js */ '../../node_modules/axios/lib/core/InterceptorManager.js'
          );
        /* harmony import */ var _dispatchRequest_js__WEBPACK_IMPORTED_MODULE_5__ =
          __webpack_require__(
            /*! ./dispatchRequest.js */ '../../node_modules/axios/lib/core/dispatchRequest.js'
          );
        /* harmony import */ var _mergeConfig_js__WEBPACK_IMPORTED_MODULE_2__ =
          __webpack_require__(
            /*! ./mergeConfig.js */ '../../node_modules/axios/lib/core/mergeConfig.js'
          );
        /* harmony import */ var _buildFullPath_js__WEBPACK_IMPORTED_MODULE_6__ =
          __webpack_require__(
            /*! ./buildFullPath.js */ '../../node_modules/axios/lib/core/buildFullPath.js'
          );
        /* harmony import */ var _helpers_validator_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ../helpers/validator.js */ '../../node_modules/axios/lib/helpers/validator.js'
          );
        /* harmony import */ var _AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_4__ =
          __webpack_require__(
            /*! ./AxiosHeaders.js */ '../../node_modules/axios/lib/core/AxiosHeaders.js'
          );

        const validators =
          _helpers_validator_js__WEBPACK_IMPORTED_MODULE_0__['default']
            .validators;

        /**
         * Create a new instance of Axios
         *
         * @param {Object} instanceConfig The default config for the instance
         *
         * @return {Axios} A new instance of Axios
         */
        class Axios {
          constructor(instanceConfig) {
            this.defaults = instanceConfig;
            this.interceptors = {
              request: new _InterceptorManager_js__WEBPACK_IMPORTED_MODULE_1__[
                'default'
              ](),
              response: new _InterceptorManager_js__WEBPACK_IMPORTED_MODULE_1__[
                'default'
              ]()
            };
          }

          /**
           * Dispatch a request
           *
           * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
           * @param {?Object} config
           *
           * @returns {Promise} The Promise to be fulfilled
           */
          async request(configOrUrl, config) {
            try {
              return await this._request(configOrUrl, config);
            } catch (err) {
              if (err instanceof Error) {
                let dummy = {};

                Error.captureStackTrace
                  ? Error.captureStackTrace(dummy)
                  : (dummy = new Error());

                // slice off the Error: ... line
                const stack = dummy.stack
                  ? dummy.stack.replace(/^.+\n/, '')
                  : '';
                try {
                  if (!err.stack) {
                    err.stack = stack;
                    // match without the 2 top stack lines
                  } else if (
                    stack &&
                    !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ''))
                  ) {
                    err.stack += '\n' + stack;
                  }
                } catch (e) {
                  // ignore the case where "stack" is an un-writable property
                }
              }

              throw err;
            }
          }

          _request(configOrUrl, config) {
            /*eslint no-param-reassign:0*/
            // Allow for axios('example/url'[, config]) a la fetch API
            if (typeof configOrUrl === 'string') {
              config = config || {};
              config.url = configOrUrl;
            } else {
              config = configOrUrl || {};
            }

            config = (0,
            _mergeConfig_js__WEBPACK_IMPORTED_MODULE_2__['default'])(
              this.defaults,
              config
            );

            const { transitional, paramsSerializer, headers } = config;

            if (transitional !== undefined) {
              _helpers_validator_js__WEBPACK_IMPORTED_MODULE_0__[
                'default'
              ].assertOptions(
                transitional,
                {
                  silentJSONParsing: validators.transitional(
                    validators.boolean
                  ),
                  forcedJSONParsing: validators.transitional(
                    validators.boolean
                  ),
                  clarifyTimeoutError: validators.transitional(
                    validators.boolean
                  )
                },
                false
              );
            }

            if (paramsSerializer != null) {
              if (
                _utils_js__WEBPACK_IMPORTED_MODULE_3__['default'].isFunction(
                  paramsSerializer
                )
              ) {
                config.paramsSerializer = {
                  serialize: paramsSerializer
                };
              } else {
                _helpers_validator_js__WEBPACK_IMPORTED_MODULE_0__[
                  'default'
                ].assertOptions(
                  paramsSerializer,
                  {
                    encode: validators.function,
                    serialize: validators.function
                  },
                  true
                );
              }
            }

            // Set config.allowAbsoluteUrls
            if (config.allowAbsoluteUrls !== undefined) {
              // do nothing
            } else if (this.defaults.allowAbsoluteUrls !== undefined) {
              config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
            } else {
              config.allowAbsoluteUrls = true;
            }

            _helpers_validator_js__WEBPACK_IMPORTED_MODULE_0__[
              'default'
            ].assertOptions(
              config,
              {
                baseUrl: validators.spelling('baseURL'),
                withXsrfToken: validators.spelling('withXSRFToken')
              },
              true
            );

            // Set config.method
            config.method = (
              config.method ||
              this.defaults.method ||
              'get'
            ).toLowerCase();

            // Flatten headers
            let contextHeaders =
              headers &&
              _utils_js__WEBPACK_IMPORTED_MODULE_3__['default'].merge(
                headers.common,
                headers[config.method]
              );

            headers &&
              _utils_js__WEBPACK_IMPORTED_MODULE_3__['default'].forEach(
                ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
                method => {
                  delete headers[method];
                }
              );

            config.headers = _AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_4__[
              'default'
            ].concat(contextHeaders, headers);

            // filter out skipped interceptors
            const requestInterceptorChain = [];
            let synchronousRequestInterceptors = true;
            this.interceptors.request.forEach(
              function unshiftRequestInterceptors(interceptor) {
                if (
                  typeof interceptor.runWhen === 'function' &&
                  interceptor.runWhen(config) === false
                ) {
                  return;
                }

                synchronousRequestInterceptors =
                  synchronousRequestInterceptors && interceptor.synchronous;

                requestInterceptorChain.unshift(
                  interceptor.fulfilled,
                  interceptor.rejected
                );
              }
            );

            const responseInterceptorChain = [];
            this.interceptors.response.forEach(
              function pushResponseInterceptors(interceptor) {
                responseInterceptorChain.push(
                  interceptor.fulfilled,
                  interceptor.rejected
                );
              }
            );

            let promise;
            let i = 0;
            let len;

            if (!synchronousRequestInterceptors) {
              const chain = [
                _dispatchRequest_js__WEBPACK_IMPORTED_MODULE_5__[
                  'default'
                ].bind(this),
                undefined
              ];
              chain.unshift.apply(chain, requestInterceptorChain);
              chain.push.apply(chain, responseInterceptorChain);
              len = chain.length;

              promise = Promise.resolve(config);

              while (i < len) {
                promise = promise.then(chain[i++], chain[i++]);
              }

              return promise;
            }

            len = requestInterceptorChain.length;

            let newConfig = config;

            i = 0;

            while (i < len) {
              const onFulfilled = requestInterceptorChain[i++];
              const onRejected = requestInterceptorChain[i++];
              try {
                newConfig = onFulfilled(newConfig);
              } catch (error) {
                onRejected.call(this, error);
                break;
              }
            }

            try {
              promise = _dispatchRequest_js__WEBPACK_IMPORTED_MODULE_5__[
                'default'
              ].call(this, newConfig);
            } catch (error) {
              return Promise.reject(error);
            }

            i = 0;
            len = responseInterceptorChain.length;

            while (i < len) {
              promise = promise.then(
                responseInterceptorChain[i++],
                responseInterceptorChain[i++]
              );
            }

            return promise;
          }

          getUri(config) {
            config = (0,
            _mergeConfig_js__WEBPACK_IMPORTED_MODULE_2__['default'])(
              this.defaults,
              config
            );
            const fullPath = (0,
            _buildFullPath_js__WEBPACK_IMPORTED_MODULE_6__['default'])(
              config.baseURL,
              config.url,
              config.allowAbsoluteUrls
            );
            return (0,
            _helpers_buildURL_js__WEBPACK_IMPORTED_MODULE_7__['default'])(
              fullPath,
              config.params,
              config.paramsSerializer
            );
          }
        }

        // Provide aliases for supported request methods
        _utils_js__WEBPACK_IMPORTED_MODULE_3__['default'].forEach(
          ['delete', 'get', 'head', 'options'],
          function forEachMethodNoData(method) {
            /*eslint func-names:0*/
            Axios.prototype[method] = function (url, config) {
              return this.request(
                (0, _mergeConfig_js__WEBPACK_IMPORTED_MODULE_2__['default'])(
                  config || {},
                  {
                    method,
                    url,
                    data: (config || {}).data
                  }
                )
              );
            };
          }
        );

        _utils_js__WEBPACK_IMPORTED_MODULE_3__['default'].forEach(
          ['post', 'put', 'patch'],
          function forEachMethodWithData(method) {
            /*eslint func-names:0*/

            function generateHTTPMethod(isForm) {
              return function httpMethod(url, data, config) {
                return this.request(
                  (0, _mergeConfig_js__WEBPACK_IMPORTED_MODULE_2__['default'])(
                    config || {},
                    {
                      method,
                      headers: isForm
                        ? {
                            'Content-Type': 'multipart/form-data'
                          }
                        : {},
                      url,
                      data
                    }
                  )
                );
              };
            }

            Axios.prototype[method] = generateHTTPMethod();

            Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
          }
        );

        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = Axios;

        /***/
      },

    /***/ '../../node_modules/axios/lib/core/AxiosError.js':
      /*!*******************************************************!*\
  !*** ../../node_modules/axios/lib/core/AxiosError.js ***!
  \*******************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__
          /* harmony export */
        });
        /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ../utils.js */ '../../node_modules/axios/lib/utils.js'
          );

        /**
         * Create an Error with the specified message, config, error code, request and response.
         *
         * @param {string} message The error message.
         * @param {string} [code] The error code (for example, 'ECONNABORTED').
         * @param {Object} [config] The config.
         * @param {Object} [request] The request.
         * @param {Object} [response] The response.
         *
         * @returns {Error} The created error.
         */
        function AxiosError(message, code, config, request, response) {
          Error.call(this);

          if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
          } else {
            this.stack = new Error().stack;
          }

          this.message = message;
          this.name = 'AxiosError';
          code && (this.code = code);
          config && (this.config = config);
          request && (this.request = request);
          if (response) {
            this.response = response;
            this.status = response.status ? response.status : null;
          }
        }

        _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].inherits(
          AxiosError,
          Error,
          {
            toJSON: function toJSON() {
              return {
                // Standard
                message: this.message,
                name: this.name,
                // Microsoft
                description: this.description,
                number: this.number,
                // Mozilla
                fileName: this.fileName,
                lineNumber: this.lineNumber,
                columnNumber: this.columnNumber,
                stack: this.stack,
                // Axios
                config: _utils_js__WEBPACK_IMPORTED_MODULE_0__[
                  'default'
                ].toJSONObject(this.config),
                code: this.code,
                status: this.status
              };
            }
          }
        );

        const prototype = AxiosError.prototype;
        const descriptors = {};

        [
          'ERR_BAD_OPTION_VALUE',
          'ERR_BAD_OPTION',
          'ECONNABORTED',
          'ETIMEDOUT',
          'ERR_NETWORK',
          'ERR_FR_TOO_MANY_REDIRECTS',
          'ERR_DEPRECATED',
          'ERR_BAD_RESPONSE',
          'ERR_BAD_REQUEST',
          'ERR_CANCELED',
          'ERR_NOT_SUPPORT',
          'ERR_INVALID_URL'
          // eslint-disable-next-line func-names
        ].forEach(code => {
          descriptors[code] = { value: code };
        });

        Object.defineProperties(AxiosError, descriptors);
        Object.defineProperty(prototype, 'isAxiosError', { value: true });

        // eslint-disable-next-line func-names
        AxiosError.from = (
          error,
          code,
          config,
          request,
          response,
          customProps
        ) => {
          const axiosError = Object.create(prototype);

          _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].toFlatObject(
            error,
            axiosError,
            function filter(obj) {
              return obj !== Error.prototype;
            },
            prop => {
              return prop !== 'isAxiosError';
            }
          );

          AxiosError.call(
            axiosError,
            error.message,
            code,
            config,
            request,
            response
          );

          axiosError.cause = error;

          axiosError.name = error.name;

          customProps && Object.assign(axiosError, customProps);

          return axiosError;
        };

        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          AxiosError;

        /***/
      },

    /***/ '../../node_modules/axios/lib/core/AxiosHeaders.js':
      /*!*********************************************************!*\
  !*** ../../node_modules/axios/lib/core/AxiosHeaders.js ***!
  \*********************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__
          /* harmony export */
        });
        /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ../utils.js */ '../../node_modules/axios/lib/utils.js'
          );
        /* harmony import */ var _helpers_parseHeaders_js__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! ../helpers/parseHeaders.js */ '../../node_modules/axios/lib/helpers/parseHeaders.js'
          );

        const $internals = Symbol('internals');

        function normalizeHeader(header) {
          return header && String(header).trim().toLowerCase();
        }

        function normalizeValue(value) {
          if (value === false || value == null) {
            return value;
          }

          return _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].isArray(
            value
          )
            ? value.map(normalizeValue)
            : String(value);
        }

        function parseTokens(str) {
          const tokens = Object.create(null);
          const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
          let match;

          while ((match = tokensRE.exec(str))) {
            tokens[match[1]] = match[2];
          }

          return tokens;
        }

        const isValidHeaderName = str =>
          /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());

        function matchHeaderValue(
          context,
          value,
          header,
          filter,
          isHeaderNameFilter
        ) {
          if (
            _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].isFunction(filter)
          ) {
            return filter.call(this, value, header);
          }

          if (isHeaderNameFilter) {
            value = header;
          }

          if (
            !_utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].isString(value)
          )
            return;

          if (
            _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].isString(filter)
          ) {
            return value.indexOf(filter) !== -1;
          }

          if (
            _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].isRegExp(filter)
          ) {
            return filter.test(value);
          }
        }

        function formatHeader(header) {
          return header
            .trim()
            .toLowerCase()
            .replace(/([a-z\d])(\w*)/g, (w, char, str) => {
              return char.toUpperCase() + str;
            });
        }

        function buildAccessors(obj, header) {
          const accessorName = _utils_js__WEBPACK_IMPORTED_MODULE_0__[
            'default'
          ].toCamelCase(' ' + header);

          ['get', 'set', 'has'].forEach(methodName => {
            Object.defineProperty(obj, methodName + accessorName, {
              value: function (arg1, arg2, arg3) {
                return this[methodName].call(this, header, arg1, arg2, arg3);
              },
              configurable: true
            });
          });
        }

        class AxiosHeaders {
          constructor(headers) {
            headers && this.set(headers);
          }

          set(header, valueOrRewrite, rewrite) {
            const self = this;

            function setHeader(_value, _header, _rewrite) {
              const lHeader = normalizeHeader(_header);

              if (!lHeader) {
                throw new Error('header name must be a non-empty string');
              }

              const key = _utils_js__WEBPACK_IMPORTED_MODULE_0__[
                'default'
              ].findKey(self, lHeader);

              if (
                !key ||
                self[key] === undefined ||
                _rewrite === true ||
                (_rewrite === undefined && self[key] !== false)
              ) {
                self[key || _header] = normalizeValue(_value);
              }
            }

            const setHeaders = (headers, _rewrite) =>
              _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].forEach(
                headers,
                (_value, _header) => setHeader(_value, _header, _rewrite)
              );

            if (
              _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].isPlainObject(
                header
              ) ||
              header instanceof this.constructor
            ) {
              setHeaders(header, valueOrRewrite);
            } else if (
              _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].isString(
                header
              ) &&
              (header = header.trim()) &&
              !isValidHeaderName(header)
            ) {
              setHeaders(
                (0,
                _helpers_parseHeaders_js__WEBPACK_IMPORTED_MODULE_1__[
                  'default'
                ])(header),
                valueOrRewrite
              );
            } else if (
              _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].isHeaders(
                header
              )
            ) {
              for (const [key, value] of header.entries()) {
                setHeader(value, key, rewrite);
              }
            } else {
              header != null && setHeader(valueOrRewrite, header, rewrite);
            }

            return this;
          }

          get(header, parser) {
            header = normalizeHeader(header);

            if (header) {
              const key = _utils_js__WEBPACK_IMPORTED_MODULE_0__[
                'default'
              ].findKey(this, header);

              if (key) {
                const value = this[key];

                if (!parser) {
                  return value;
                }

                if (parser === true) {
                  return parseTokens(value);
                }

                if (
                  _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].isFunction(
                    parser
                  )
                ) {
                  return parser.call(this, value, key);
                }

                if (
                  _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].isRegExp(
                    parser
                  )
                ) {
                  return parser.exec(value);
                }

                throw new TypeError('parser must be boolean|regexp|function');
              }
            }
          }

          has(header, matcher) {
            header = normalizeHeader(header);

            if (header) {
              const key = _utils_js__WEBPACK_IMPORTED_MODULE_0__[
                'default'
              ].findKey(this, header);

              return !!(
                key &&
                this[key] !== undefined &&
                (!matcher || matchHeaderValue(this, this[key], key, matcher))
              );
            }

            return false;
          }

          delete(header, matcher) {
            const self = this;
            let deleted = false;

            function deleteHeader(_header) {
              _header = normalizeHeader(_header);

              if (_header) {
                const key = _utils_js__WEBPACK_IMPORTED_MODULE_0__[
                  'default'
                ].findKey(self, _header);

                if (
                  key &&
                  (!matcher || matchHeaderValue(self, self[key], key, matcher))
                ) {
                  delete self[key];

                  deleted = true;
                }
              }
            }

            if (
              _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].isArray(header)
            ) {
              header.forEach(deleteHeader);
            } else {
              deleteHeader(header);
            }

            return deleted;
          }

          clear(matcher) {
            const keys = Object.keys(this);
            let i = keys.length;
            let deleted = false;

            while (i--) {
              const key = keys[i];
              if (
                !matcher ||
                matchHeaderValue(this, this[key], key, matcher, true)
              ) {
                delete this[key];
                deleted = true;
              }
            }

            return deleted;
          }

          normalize(format) {
            const self = this;
            const headers = {};

            _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].forEach(
              this,
              (value, header) => {
                const key = _utils_js__WEBPACK_IMPORTED_MODULE_0__[
                  'default'
                ].findKey(headers, header);

                if (key) {
                  self[key] = normalizeValue(value);
                  delete self[header];
                  return;
                }

                const normalized = format
                  ? formatHeader(header)
                  : String(header).trim();

                if (normalized !== header) {
                  delete self[header];
                }

                self[normalized] = normalizeValue(value);

                headers[normalized] = true;
              }
            );

            return this;
          }

          concat(...targets) {
            return this.constructor.concat(this, ...targets);
          }

          toJSON(asStrings) {
            const obj = Object.create(null);

            _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].forEach(
              this,
              (value, header) => {
                value != null &&
                  value !== false &&
                  (obj[header] =
                    asStrings &&
                    _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].isArray(
                      value
                    )
                      ? value.join(', ')
                      : value);
              }
            );

            return obj;
          }

          [Symbol.iterator]() {
            return Object.entries(this.toJSON())[Symbol.iterator]();
          }

          toString() {
            return Object.entries(this.toJSON())
              .map(([header, value]) => header + ': ' + value)
              .join('\n');
          }

          get [Symbol.toStringTag]() {
            return 'AxiosHeaders';
          }

          static from(thing) {
            return thing instanceof this ? thing : new this(thing);
          }

          static concat(first, ...targets) {
            const computed = new this(first);

            targets.forEach(target => computed.set(target));

            return computed;
          }

          static accessor(header) {
            const internals =
              (this[$internals] =
              this[$internals] =
                {
                  accessors: {}
                });

            const accessors = internals.accessors;
            const prototype = this.prototype;

            function defineAccessor(_header) {
              const lHeader = normalizeHeader(_header);

              if (!accessors[lHeader]) {
                buildAccessors(prototype, _header);
                accessors[lHeader] = true;
              }
            }

            _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].isArray(header)
              ? header.forEach(defineAccessor)
              : defineAccessor(header);

            return this;
          }
        }

        AxiosHeaders.accessor([
          'Content-Type',
          'Content-Length',
          'Accept',
          'Accept-Encoding',
          'User-Agent',
          'Authorization'
        ]);

        // reserved names hotfix
        _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].reduceDescriptors(
          AxiosHeaders.prototype,
          ({ value }, key) => {
            let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`
            return {
              get: () => value,
              set(headerValue) {
                this[mapped] = headerValue;
              }
            };
          }
        );

        _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].freezeMethods(
          AxiosHeaders
        );

        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          AxiosHeaders;

        /***/
      },

    /***/ '../../node_modules/axios/lib/core/InterceptorManager.js':
      /*!***************************************************************!*\
  !*** ../../node_modules/axios/lib/core/InterceptorManager.js ***!
  \***************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__
          /* harmony export */
        });
        /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ./../utils.js */ '../../node_modules/axios/lib/utils.js'
          );

        class InterceptorManager {
          constructor() {
            this.handlers = [];
          }

          /**
           * Add a new interceptor to the stack
           *
           * @param {Function} fulfilled The function to handle `then` for a `Promise`
           * @param {Function} rejected The function to handle `reject` for a `Promise`
           *
           * @return {Number} An ID used to remove interceptor later
           */
          use(fulfilled, rejected, options) {
            this.handlers.push({
              fulfilled,
              rejected,
              synchronous: options ? options.synchronous : false,
              runWhen: options ? options.runWhen : null
            });
            return this.handlers.length - 1;
          }

          /**
           * Remove an interceptor from the stack
           *
           * @param {Number} id The ID that was returned by `use`
           *
           * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
           */
          eject(id) {
            if (this.handlers[id]) {
              this.handlers[id] = null;
            }
          }

          /**
           * Clear all interceptors from the stack
           *
           * @returns {void}
           */
          clear() {
            if (this.handlers) {
              this.handlers = [];
            }
          }

          /**
           * Iterate over all the registered interceptors
           *
           * This method is particularly useful for skipping over any
           * interceptors that may have become `null` calling `eject`.
           *
           * @param {Function} fn The function to call for each interceptor
           *
           * @returns {void}
           */
          forEach(fn) {
            _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].forEach(
              this.handlers,
              function forEachHandler(h) {
                if (h !== null) {
                  fn(h);
                }
              }
            );
          }
        }

        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          InterceptorManager;

        /***/
      },

    /***/ '../../node_modules/axios/lib/core/buildFullPath.js':
      /*!**********************************************************!*\
  !*** ../../node_modules/axios/lib/core/buildFullPath.js ***!
  \**********************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => /* binding */ buildFullPath
          /* harmony export */
        });
        /* harmony import */ var _helpers_isAbsoluteURL_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ../helpers/isAbsoluteURL.js */ '../../node_modules/axios/lib/helpers/isAbsoluteURL.js'
          );
        /* harmony import */ var _helpers_combineURLs_js__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! ../helpers/combineURLs.js */ '../../node_modules/axios/lib/helpers/combineURLs.js'
          );

        /**
         * Creates a new URL by combining the baseURL with the requestedURL,
         * only when the requestedURL is not already an absolute URL.
         * If the requestURL is absolute, this function returns the requestedURL untouched.
         *
         * @param {string} baseURL The base URL
         * @param {string} requestedURL Absolute or relative URL to combine
         *
         * @returns {string} The combined full path
         */
        function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
          let isRelativeUrl = !(0,
          _helpers_isAbsoluteURL_js__WEBPACK_IMPORTED_MODULE_0__['default'])(
            requestedURL
          );
          if ((baseURL && isRelativeUrl) || allowAbsoluteUrls == false) {
            return (0,
            _helpers_combineURLs_js__WEBPACK_IMPORTED_MODULE_1__['default'])(
              baseURL,
              requestedURL
            );
          }
          return requestedURL;
        }

        /***/
      },

    /***/ '../../node_modules/axios/lib/core/dispatchRequest.js':
      /*!************************************************************!*\
  !*** ../../node_modules/axios/lib/core/dispatchRequest.js ***!
  \************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => /* binding */ dispatchRequest
          /* harmony export */
        });
        /* harmony import */ var _transformData_js__WEBPACK_IMPORTED_MODULE_2__ =
          __webpack_require__(
            /*! ./transformData.js */ '../../node_modules/axios/lib/core/transformData.js'
          );
        /* harmony import */ var _cancel_isCancel_js__WEBPACK_IMPORTED_MODULE_5__ =
          __webpack_require__(
            /*! ../cancel/isCancel.js */ '../../node_modules/axios/lib/cancel/isCancel.js'
          );
        /* harmony import */ var _defaults_index_js__WEBPACK_IMPORTED_MODULE_4__ =
          __webpack_require__(
            /*! ../defaults/index.js */ '../../node_modules/axios/lib/defaults/index.js'
          );
        /* harmony import */ var _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ../cancel/CanceledError.js */ '../../node_modules/axios/lib/cancel/CanceledError.js'
          );
        /* harmony import */ var _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! ../core/AxiosHeaders.js */ '../../node_modules/axios/lib/core/AxiosHeaders.js'
          );
        /* harmony import */ var _adapters_adapters_js__WEBPACK_IMPORTED_MODULE_3__ =
          __webpack_require__(
            /*! ../adapters/adapters.js */ '../../node_modules/axios/lib/adapters/adapters.js'
          );

        /**
         * Throws a `CanceledError` if cancellation has been requested.
         *
         * @param {Object} config The config that is to be used for the request
         *
         * @returns {void}
         */
        function throwIfCancellationRequested(config) {
          if (config.cancelToken) {
            config.cancelToken.throwIfRequested();
          }

          if (config.signal && config.signal.aborted) {
            throw new _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_0__[
              'default'
            ](null, config);
          }
        }

        /**
         * Dispatch a request to the server using the configured adapter.
         *
         * @param {object} config The config that is to be used for the request
         *
         * @returns {Promise} The Promise to be fulfilled
         */
        function dispatchRequest(config) {
          throwIfCancellationRequested(config);

          config.headers = _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__[
            'default'
          ].from(config.headers);

          // Transform request data
          config.data = _transformData_js__WEBPACK_IMPORTED_MODULE_2__[
            'default'
          ].call(config, config.transformRequest);

          if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {
            config.headers.setContentType(
              'application/x-www-form-urlencoded',
              false
            );
          }

          const adapter = _adapters_adapters_js__WEBPACK_IMPORTED_MODULE_3__[
            'default'
          ].getAdapter(
            config.adapter ||
              _defaults_index_js__WEBPACK_IMPORTED_MODULE_4__['default'].adapter
          );

          return adapter(config).then(
            function onAdapterResolution(response) {
              throwIfCancellationRequested(config);

              // Transform response data
              response.data = _transformData_js__WEBPACK_IMPORTED_MODULE_2__[
                'default'
              ].call(config, config.transformResponse, response);

              response.headers =
                _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__[
                  'default'
                ].from(response.headers);

              return response;
            },
            function onAdapterRejection(reason) {
              if (
                !(0,
                _cancel_isCancel_js__WEBPACK_IMPORTED_MODULE_5__['default'])(
                  reason
                )
              ) {
                throwIfCancellationRequested(config);

                // Transform response data
                if (reason && reason.response) {
                  reason.response.data =
                    _transformData_js__WEBPACK_IMPORTED_MODULE_2__[
                      'default'
                    ].call(config, config.transformResponse, reason.response);
                  reason.response.headers =
                    _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__[
                      'default'
                    ].from(reason.response.headers);
                }
              }

              return Promise.reject(reason);
            }
          );
        }

        /***/
      },

    /***/ '../../node_modules/axios/lib/core/mergeConfig.js':
      /*!********************************************************!*\
  !*** ../../node_modules/axios/lib/core/mergeConfig.js ***!
  \********************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => /* binding */ mergeConfig
          /* harmony export */
        });
        /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! ../utils.js */ '../../node_modules/axios/lib/utils.js'
          );
        /* harmony import */ var _AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ./AxiosHeaders.js */ '../../node_modules/axios/lib/core/AxiosHeaders.js'
          );

        const headersToObject = thing =>
          thing instanceof
          _AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_0__['default']
            ? { ...thing }
            : thing;

        /**
         * Config-specific merge-function which creates a new config-object
         * by merging two configuration objects together.
         *
         * @param {Object} config1
         * @param {Object} config2
         *
         * @returns {Object} New object resulting from merging config2 to config1
         */
        function mergeConfig(config1, config2) {
          // eslint-disable-next-line no-param-reassign
          config2 = config2 || {};
          const config = {};

          function getMergedValue(target, source, prop, caseless) {
            if (
              _utils_js__WEBPACK_IMPORTED_MODULE_1__['default'].isPlainObject(
                target
              ) &&
              _utils_js__WEBPACK_IMPORTED_MODULE_1__['default'].isPlainObject(
                source
              )
            ) {
              return _utils_js__WEBPACK_IMPORTED_MODULE_1__[
                'default'
              ].merge.call({ caseless }, target, source);
            } else if (
              _utils_js__WEBPACK_IMPORTED_MODULE_1__['default'].isPlainObject(
                source
              )
            ) {
              return _utils_js__WEBPACK_IMPORTED_MODULE_1__['default'].merge(
                {},
                source
              );
            } else if (
              _utils_js__WEBPACK_IMPORTED_MODULE_1__['default'].isArray(source)
            ) {
              return source.slice();
            }
            return source;
          }

          // eslint-disable-next-line consistent-return
          function mergeDeepProperties(a, b, prop, caseless) {
            if (
              !_utils_js__WEBPACK_IMPORTED_MODULE_1__['default'].isUndefined(b)
            ) {
              return getMergedValue(a, b, prop, caseless);
            } else if (
              !_utils_js__WEBPACK_IMPORTED_MODULE_1__['default'].isUndefined(a)
            ) {
              return getMergedValue(undefined, a, prop, caseless);
            }
          }

          // eslint-disable-next-line consistent-return
          function valueFromConfig2(a, b) {
            if (
              !_utils_js__WEBPACK_IMPORTED_MODULE_1__['default'].isUndefined(b)
            ) {
              return getMergedValue(undefined, b);
            }
          }

          // eslint-disable-next-line consistent-return
          function defaultToConfig2(a, b) {
            if (
              !_utils_js__WEBPACK_IMPORTED_MODULE_1__['default'].isUndefined(b)
            ) {
              return getMergedValue(undefined, b);
            } else if (
              !_utils_js__WEBPACK_IMPORTED_MODULE_1__['default'].isUndefined(a)
            ) {
              return getMergedValue(undefined, a);
            }
          }

          // eslint-disable-next-line consistent-return
          function mergeDirectKeys(a, b, prop) {
            if (prop in config2) {
              return getMergedValue(a, b);
            } else if (prop in config1) {
              return getMergedValue(undefined, a);
            }
          }

          const mergeMap = {
            url: valueFromConfig2,
            method: valueFromConfig2,
            data: valueFromConfig2,
            baseURL: defaultToConfig2,
            transformRequest: defaultToConfig2,
            transformResponse: defaultToConfig2,
            paramsSerializer: defaultToConfig2,
            timeout: defaultToConfig2,
            timeoutMessage: defaultToConfig2,
            withCredentials: defaultToConfig2,
            withXSRFToken: defaultToConfig2,
            adapter: defaultToConfig2,
            responseType: defaultToConfig2,
            xsrfCookieName: defaultToConfig2,
            xsrfHeaderName: defaultToConfig2,
            onUploadProgress: defaultToConfig2,
            onDownloadProgress: defaultToConfig2,
            decompress: defaultToConfig2,
            maxContentLength: defaultToConfig2,
            maxBodyLength: defaultToConfig2,
            beforeRedirect: defaultToConfig2,
            transport: defaultToConfig2,
            httpAgent: defaultToConfig2,
            httpsAgent: defaultToConfig2,
            cancelToken: defaultToConfig2,
            socketPath: defaultToConfig2,
            responseEncoding: defaultToConfig2,
            validateStatus: mergeDirectKeys,
            headers: (a, b, prop) =>
              mergeDeepProperties(
                headersToObject(a),
                headersToObject(b),
                prop,
                true
              )
          };

          _utils_js__WEBPACK_IMPORTED_MODULE_1__['default'].forEach(
            Object.keys(Object.assign({}, config1, config2)),
            function computeConfigValue(prop) {
              const merge = mergeMap[prop] || mergeDeepProperties;
              const configValue = merge(config1[prop], config2[prop], prop);
              (_utils_js__WEBPACK_IMPORTED_MODULE_1__['default'].isUndefined(
                configValue
              ) &&
                merge !== mergeDirectKeys) ||
                (config[prop] = configValue);
            }
          );

          return config;
        }

        /***/
      },

    /***/ '../../node_modules/axios/lib/core/settle.js':
      /*!***************************************************!*\
  !*** ../../node_modules/axios/lib/core/settle.js ***!
  \***************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => /* binding */ settle
          /* harmony export */
        });
        /* harmony import */ var _AxiosError_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ./AxiosError.js */ '../../node_modules/axios/lib/core/AxiosError.js'
          );

        /**
         * Resolve or reject a Promise based on response status.
         *
         * @param {Function} resolve A function that resolves the promise.
         * @param {Function} reject A function that rejects the promise.
         * @param {object} response The response.
         *
         * @returns {object} The response.
         */
        function settle(resolve, reject, response) {
          const validateStatus = response.config.validateStatus;
          if (
            !response.status ||
            !validateStatus ||
            validateStatus(response.status)
          ) {
            resolve(response);
          } else {
            reject(
              new _AxiosError_js__WEBPACK_IMPORTED_MODULE_0__['default'](
                'Request failed with status code ' + response.status,
                [
                  _AxiosError_js__WEBPACK_IMPORTED_MODULE_0__['default']
                    .ERR_BAD_REQUEST,
                  _AxiosError_js__WEBPACK_IMPORTED_MODULE_0__['default']
                    .ERR_BAD_RESPONSE
                ][Math.floor(response.status / 100) - 4],
                response.config,
                response.request,
                response
              )
            );
          }
        }

        /***/
      },

    /***/ '../../node_modules/axios/lib/core/transformData.js':
      /*!**********************************************************!*\
  !*** ../../node_modules/axios/lib/core/transformData.js ***!
  \**********************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => /* binding */ transformData
          /* harmony export */
        });
        /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ =
          __webpack_require__(
            /*! ./../utils.js */ '../../node_modules/axios/lib/utils.js'
          );
        /* harmony import */ var _defaults_index_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ../defaults/index.js */ '../../node_modules/axios/lib/defaults/index.js'
          );
        /* harmony import */ var _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! ../core/AxiosHeaders.js */ '../../node_modules/axios/lib/core/AxiosHeaders.js'
          );

        /**
         * Transform the data for a request or a response
         *
         * @param {Array|Function} fns A single function or Array of functions
         * @param {?Object} response The response object
         *
         * @returns {*} The resulting transformed data
         */
        function transformData(fns, response) {
          const config =
            this || _defaults_index_js__WEBPACK_IMPORTED_MODULE_0__['default'];
          const context = response || config;
          const headers = _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__[
            'default'
          ].from(context.headers);
          let data = context.data;

          _utils_js__WEBPACK_IMPORTED_MODULE_2__['default'].forEach(
            fns,
            function transform(fn) {
              data = fn.call(
                config,
                data,
                headers.normalize(),
                response ? response.status : undefined
              );
            }
          );

          headers.normalize();

          return data;
        }

        /***/
      },

    /***/ '../../node_modules/axios/lib/defaults/index.js':
      /*!******************************************************!*\
  !*** ../../node_modules/axios/lib/defaults/index.js ***!
  \******************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__
          /* harmony export */
        });
        /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ../utils.js */ '../../node_modules/axios/lib/utils.js'
          );
        /* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_5__ =
          __webpack_require__(
            /*! ../core/AxiosError.js */ '../../node_modules/axios/lib/core/AxiosError.js'
          );
        /* harmony import */ var _transitional_js__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! ./transitional.js */ '../../node_modules/axios/lib/defaults/transitional.js'
          );
        /* harmony import */ var _helpers_toFormData_js__WEBPACK_IMPORTED_MODULE_4__ =
          __webpack_require__(
            /*! ../helpers/toFormData.js */ '../../node_modules/axios/lib/helpers/toFormData.js'
          );
        /* harmony import */ var _helpers_toURLEncodedForm_js__WEBPACK_IMPORTED_MODULE_3__ =
          __webpack_require__(
            /*! ../helpers/toURLEncodedForm.js */ '../../node_modules/axios/lib/helpers/toURLEncodedForm.js'
          );
        /* harmony import */ var _platform_index_js__WEBPACK_IMPORTED_MODULE_6__ =
          __webpack_require__(
            /*! ../platform/index.js */ '../../node_modules/axios/lib/platform/index.js'
          );
        /* harmony import */ var _helpers_formDataToJSON_js__WEBPACK_IMPORTED_MODULE_2__ =
          __webpack_require__(
            /*! ../helpers/formDataToJSON.js */ '../../node_modules/axios/lib/helpers/formDataToJSON.js'
          );

        /**
         * It takes a string, tries to parse it, and if it fails, it returns the stringified version
         * of the input
         *
         * @param {any} rawValue - The value to be stringified.
         * @param {Function} parser - A function that parses a string into a JavaScript object.
         * @param {Function} encoder - A function that takes a value and returns a string.
         *
         * @returns {string} A stringified version of the rawValue.
         */
        function stringifySafely(rawValue, parser, encoder) {
          if (
            _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].isString(rawValue)
          ) {
            try {
              (parser || JSON.parse)(rawValue);
              return _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].trim(
                rawValue
              );
            } catch (e) {
              if (e.name !== 'SyntaxError') {
                throw e;
              }
            }
          }

          return (encoder || JSON.stringify)(rawValue);
        }

        const defaults = {
          transitional:
            _transitional_js__WEBPACK_IMPORTED_MODULE_1__['default'],

          adapter: ['xhr', 'http', 'fetch'],

          transformRequest: [
            function transformRequest(data, headers) {
              const contentType = headers.getContentType() || '';
              const hasJSONContentType =
                contentType.indexOf('application/json') > -1;
              const isObjectPayload =
                _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].isObject(
                  data
                );

              if (
                isObjectPayload &&
                _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].isHTMLForm(
                  data
                )
              ) {
                data = new FormData(data);
              }

              const isFormData =
                _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].isFormData(
                  data
                );

              if (isFormData) {
                return hasJSONContentType
                  ? JSON.stringify(
                      (0,
                      _helpers_formDataToJSON_js__WEBPACK_IMPORTED_MODULE_2__[
                        'default'
                      ])(data)
                    )
                  : data;
              }

              if (
                _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].isArrayBuffer(
                  data
                ) ||
                _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].isBuffer(
                  data
                ) ||
                _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].isStream(
                  data
                ) ||
                _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].isFile(
                  data
                ) ||
                _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].isBlob(
                  data
                ) ||
                _utils_js__WEBPACK_IMPORTED_MODULE_0__[
                  'default'
                ].isReadableStream(data)
              ) {
                return data;
              }
              if (
                _utils_js__WEBPACK_IMPORTED_MODULE_0__[
                  'default'
                ].isArrayBufferView(data)
              ) {
                return data.buffer;
              }
              if (
                _utils_js__WEBPACK_IMPORTED_MODULE_0__[
                  'default'
                ].isURLSearchParams(data)
              ) {
                headers.setContentType(
                  'application/x-www-form-urlencoded;charset=utf-8',
                  false
                );
                return data.toString();
              }

              let isFileList;

              if (isObjectPayload) {
                if (
                  contentType.indexOf('application/x-www-form-urlencoded') > -1
                ) {
                  return (0,
                  _helpers_toURLEncodedForm_js__WEBPACK_IMPORTED_MODULE_3__[
                    'default'
                  ])(data, this.formSerializer).toString();
                }

                if (
                  (isFileList =
                    _utils_js__WEBPACK_IMPORTED_MODULE_0__[
                      'default'
                    ].isFileList(data)) ||
                  contentType.indexOf('multipart/form-data') > -1
                ) {
                  const _FormData = this.env && this.env.FormData;

                  return (0,
                  _helpers_toFormData_js__WEBPACK_IMPORTED_MODULE_4__[
                    'default'
                  ])(
                    isFileList ? { 'files[]': data } : data,
                    _FormData && new _FormData(),
                    this.formSerializer
                  );
                }
              }

              if (isObjectPayload || hasJSONContentType) {
                headers.setContentType('application/json', false);
                return stringifySafely(data);
              }

              return data;
            }
          ],

          transformResponse: [
            function transformResponse(data) {
              const transitional = this.transitional || defaults.transitional;
              const forcedJSONParsing =
                transitional && transitional.forcedJSONParsing;
              const JSONRequested = this.responseType === 'json';

              if (
                _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].isResponse(
                  data
                ) ||
                _utils_js__WEBPACK_IMPORTED_MODULE_0__[
                  'default'
                ].isReadableStream(data)
              ) {
                return data;
              }

              if (
                data &&
                _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].isString(
                  data
                ) &&
                ((forcedJSONParsing && !this.responseType) || JSONRequested)
              ) {
                const silentJSONParsing =
                  transitional && transitional.silentJSONParsing;
                const strictJSONParsing = !silentJSONParsing && JSONRequested;

                try {
                  return JSON.parse(data);
                } catch (e) {
                  if (strictJSONParsing) {
                    if (e.name === 'SyntaxError') {
                      throw _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_5__[
                        'default'
                      ].from(
                        e,
                        _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_5__[
                          'default'
                        ].ERR_BAD_RESPONSE,
                        this,
                        null,
                        this.response
                      );
                    }
                    throw e;
                  }
                }
              }

              return data;
            }
          ],

          /**
           * A timeout in milliseconds to abort a request. If set to 0 (default) a
           * timeout is not created.
           */
          timeout: 0,

          xsrfCookieName: 'XSRF-TOKEN',
          xsrfHeaderName: 'X-XSRF-TOKEN',

          maxContentLength: -1,
          maxBodyLength: -1,

          env: {
            FormData:
              _platform_index_js__WEBPACK_IMPORTED_MODULE_6__['default'].classes
                .FormData,
            Blob: _platform_index_js__WEBPACK_IMPORTED_MODULE_6__['default']
              .classes.Blob
          },

          validateStatus: function validateStatus(status) {
            return status >= 200 && status < 300;
          },

          headers: {
            common: {
              Accept: 'application/json, text/plain, */*',
              'Content-Type': undefined
            }
          }
        };

        _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].forEach(
          ['delete', 'get', 'head', 'post', 'put', 'patch'],
          method => {
            defaults.headers[method] = {};
          }
        );

        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          defaults;

        /***/
      },

    /***/ '../../node_modules/axios/lib/defaults/transitional.js':
      /*!*************************************************************!*\
  !*** ../../node_modules/axios/lib/defaults/transitional.js ***!
  \*************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__
          /* harmony export */
        });

        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = {
          silentJSONParsing: true,
          forcedJSONParsing: true,
          clarifyTimeoutError: false
        };

        /***/
      },

    /***/ '../../node_modules/axios/lib/env/data.js':
      /*!************************************************!*\
  !*** ../../node_modules/axios/lib/env/data.js ***!
  \************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ VERSION: () => /* binding */ VERSION
          /* harmony export */
        });
        const VERSION = '1.8.3';

        /***/
      },

    /***/ '../../node_modules/axios/lib/helpers/AxiosURLSearchParams.js':
      /*!********************************************************************!*\
  !*** ../../node_modules/axios/lib/helpers/AxiosURLSearchParams.js ***!
  \********************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__
          /* harmony export */
        });
        /* harmony import */ var _toFormData_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ./toFormData.js */ '../../node_modules/axios/lib/helpers/toFormData.js'
          );

        /**
         * It encodes a string by replacing all characters that are not in the unreserved set with
         * their percent-encoded equivalents
         *
         * @param {string} str - The string to encode.
         *
         * @returns {string} The encoded string.
         */
        function encode(str) {
          const charMap = {
            '!': '%21',
            "'": '%27',
            '(': '%28',
            ')': '%29',
            '~': '%7E',
            '%20': '+',
            '%00': '\x00'
          };
          return encodeURIComponent(str).replace(
            /[!'()~]|%20|%00/g,
            function replacer(match) {
              return charMap[match];
            }
          );
        }

        /**
         * It takes a params object and converts it to a FormData object
         *
         * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
         * @param {Object<string, any>} options - The options object passed to the Axios constructor.
         *
         * @returns {void}
         */
        function AxiosURLSearchParams(params, options) {
          this._pairs = [];

          params &&
            (0, _toFormData_js__WEBPACK_IMPORTED_MODULE_0__['default'])(
              params,
              this,
              options
            );
        }

        const prototype = AxiosURLSearchParams.prototype;

        prototype.append = function append(name, value) {
          this._pairs.push([name, value]);
        };

        prototype.toString = function toString(encoder) {
          const _encode = encoder
            ? function (value) {
                return encoder.call(this, value, encode);
              }
            : encode;

          return this._pairs
            .map(function each(pair) {
              return _encode(pair[0]) + '=' + _encode(pair[1]);
            }, '')
            .join('&');
        };

        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          AxiosURLSearchParams;

        /***/
      },

    /***/ '../../node_modules/axios/lib/helpers/HttpStatusCode.js':
      /*!**************************************************************!*\
  !*** ../../node_modules/axios/lib/helpers/HttpStatusCode.js ***!
  \**************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__
          /* harmony export */
        });
        const HttpStatusCode = {
          Continue: 100,
          SwitchingProtocols: 101,
          Processing: 102,
          EarlyHints: 103,
          Ok: 200,
          Created: 201,
          Accepted: 202,
          NonAuthoritativeInformation: 203,
          NoContent: 204,
          ResetContent: 205,
          PartialContent: 206,
          MultiStatus: 207,
          AlreadyReported: 208,
          ImUsed: 226,
          MultipleChoices: 300,
          MovedPermanently: 301,
          Found: 302,
          SeeOther: 303,
          NotModified: 304,
          UseProxy: 305,
          Unused: 306,
          TemporaryRedirect: 307,
          PermanentRedirect: 308,
          BadRequest: 400,
          Unauthorized: 401,
          PaymentRequired: 402,
          Forbidden: 403,
          NotFound: 404,
          MethodNotAllowed: 405,
          NotAcceptable: 406,
          ProxyAuthenticationRequired: 407,
          RequestTimeout: 408,
          Conflict: 409,
          Gone: 410,
          LengthRequired: 411,
          PreconditionFailed: 412,
          PayloadTooLarge: 413,
          UriTooLong: 414,
          UnsupportedMediaType: 415,
          RangeNotSatisfiable: 416,
          ExpectationFailed: 417,
          ImATeapot: 418,
          MisdirectedRequest: 421,
          UnprocessableEntity: 422,
          Locked: 423,
          FailedDependency: 424,
          TooEarly: 425,
          UpgradeRequired: 426,
          PreconditionRequired: 428,
          TooManyRequests: 429,
          RequestHeaderFieldsTooLarge: 431,
          UnavailableForLegalReasons: 451,
          InternalServerError: 500,
          NotImplemented: 501,
          BadGateway: 502,
          ServiceUnavailable: 503,
          GatewayTimeout: 504,
          HttpVersionNotSupported: 505,
          VariantAlsoNegotiates: 506,
          InsufficientStorage: 507,
          LoopDetected: 508,
          NotExtended: 510,
          NetworkAuthenticationRequired: 511
        };

        Object.entries(HttpStatusCode).forEach(([key, value]) => {
          HttpStatusCode[value] = key;
        });

        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          HttpStatusCode;

        /***/
      },

    /***/ '../../node_modules/axios/lib/helpers/bind.js':
      /*!****************************************************!*\
  !*** ../../node_modules/axios/lib/helpers/bind.js ***!
  \****************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => /* binding */ bind
          /* harmony export */
        });

        function bind(fn, thisArg) {
          return function wrap() {
            return fn.apply(thisArg, arguments);
          };
        }

        /***/
      },

    /***/ '../../node_modules/axios/lib/helpers/buildURL.js':
      /*!********************************************************!*\
  !*** ../../node_modules/axios/lib/helpers/buildURL.js ***!
  \********************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => /* binding */ buildURL
          /* harmony export */
        });
        /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ../utils.js */ '../../node_modules/axios/lib/utils.js'
          );
        /* harmony import */ var _helpers_AxiosURLSearchParams_js__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! ../helpers/AxiosURLSearchParams.js */ '../../node_modules/axios/lib/helpers/AxiosURLSearchParams.js'
          );

        /**
         * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
         * URI encoded counterparts
         *
         * @param {string} val The value to be encoded.
         *
         * @returns {string} The encoded value.
         */
        function encode(val) {
          return encodeURIComponent(val)
            .replace(/%3A/gi, ':')
            .replace(/%24/g, '$')
            .replace(/%2C/gi, ',')
            .replace(/%20/g, '+')
            .replace(/%5B/gi, '[')
            .replace(/%5D/gi, ']');
        }

        /**
         * Build a URL by appending params to the end
         *
         * @param {string} url The base of the url (e.g., http://www.google.com)
         * @param {object} [params] The params to be appended
         * @param {?(object|Function)} options
         *
         * @returns {string} The formatted url
         */
        function buildURL(url, params, options) {
          /*eslint no-param-reassign:0*/
          if (!params) {
            return url;
          }

          const _encode = (options && options.encode) || encode;

          if (
            _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].isFunction(
              options
            )
          ) {
            options = {
              serialize: options
            };
          }

          const serializeFn = options && options.serialize;

          let serializedParams;

          if (serializeFn) {
            serializedParams = serializeFn(params, options);
          } else {
            serializedParams = _utils_js__WEBPACK_IMPORTED_MODULE_0__[
              'default'
            ].isURLSearchParams(params)
              ? params.toString()
              : new _helpers_AxiosURLSearchParams_js__WEBPACK_IMPORTED_MODULE_1__[
                  'default'
                ](params, options).toString(_encode);
          }

          if (serializedParams) {
            const hashmarkIndex = url.indexOf('#');

            if (hashmarkIndex !== -1) {
              url = url.slice(0, hashmarkIndex);
            }
            url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
          }

          return url;
        }

        /***/
      },

    /***/ '../../node_modules/axios/lib/helpers/combineURLs.js':
      /*!***********************************************************!*\
  !*** ../../node_modules/axios/lib/helpers/combineURLs.js ***!
  \***********************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => /* binding */ combineURLs
          /* harmony export */
        });

        /**
         * Creates a new URL by combining the specified URLs
         *
         * @param {string} baseURL The base URL
         * @param {string} relativeURL The relative URL
         *
         * @returns {string} The combined URL
         */
        function combineURLs(baseURL, relativeURL) {
          return relativeURL
            ? baseURL.replace(/\/?\/$/, '') +
                '/' +
                relativeURL.replace(/^\/+/, '')
            : baseURL;
        }

        /***/
      },

    /***/ '../../node_modules/axios/lib/helpers/composeSignals.js':
      /*!**************************************************************!*\
  !*** ../../node_modules/axios/lib/helpers/composeSignals.js ***!
  \**************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__
          /* harmony export */
        });
        /* harmony import */ var _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! ../cancel/CanceledError.js */ '../../node_modules/axios/lib/cancel/CanceledError.js'
          );
        /* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ../core/AxiosError.js */ '../../node_modules/axios/lib/core/AxiosError.js'
          );
        /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ =
          __webpack_require__(
            /*! ../utils.js */ '../../node_modules/axios/lib/utils.js'
          );

        const composeSignals = (signals, timeout) => {
          const { length } = (signals = signals ? signals.filter(Boolean) : []);

          if (timeout || length) {
            let controller = new AbortController();

            let aborted;

            const onabort = function (reason) {
              if (!aborted) {
                aborted = true;
                unsubscribe();
                const err = reason instanceof Error ? reason : this.reason;
                controller.abort(
                  err instanceof
                    _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_0__['default']
                    ? err
                    : new _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_1__[
                        'default'
                      ](err instanceof Error ? err.message : err)
                );
              }
            };

            let timer =
              timeout &&
              setTimeout(() => {
                timer = null;
                onabort(
                  new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_0__[
                    'default'
                  ](
                    `timeout ${timeout} of ms exceeded`,
                    _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_0__['default']
                      .ETIMEDOUT
                  )
                );
              }, timeout);

            const unsubscribe = () => {
              if (signals) {
                timer && clearTimeout(timer);
                timer = null;
                signals.forEach(signal => {
                  signal.unsubscribe
                    ? signal.unsubscribe(onabort)
                    : signal.removeEventListener('abort', onabort);
                });
                signals = null;
              }
            };

            signals.forEach(signal =>
              signal.addEventListener('abort', onabort)
            );

            const { signal } = controller;

            signal.unsubscribe = () =>
              _utils_js__WEBPACK_IMPORTED_MODULE_2__['default'].asap(
                unsubscribe
              );

            return signal;
          }
        };

        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          composeSignals;

        /***/
      },

    /***/ '../../node_modules/axios/lib/helpers/cookies.js':
      /*!*******************************************************!*\
  !*** ../../node_modules/axios/lib/helpers/cookies.js ***!
  \*******************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__
          /* harmony export */
        });
        /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! ./../utils.js */ '../../node_modules/axios/lib/utils.js'
          );
        /* harmony import */ var _platform_index_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ../platform/index.js */ '../../node_modules/axios/lib/platform/index.js'
          );

        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          _platform_index_js__WEBPACK_IMPORTED_MODULE_0__['default']
            .hasStandardBrowserEnv
            ? // Standard browser envs support document.cookie
              {
                write(name, value, expires, path, domain, secure) {
                  const cookie = [name + '=' + encodeURIComponent(value)];

                  _utils_js__WEBPACK_IMPORTED_MODULE_1__['default'].isNumber(
                    expires
                  ) &&
                    cookie.push('expires=' + new Date(expires).toGMTString());

                  _utils_js__WEBPACK_IMPORTED_MODULE_1__['default'].isString(
                    path
                  ) && cookie.push('path=' + path);

                  _utils_js__WEBPACK_IMPORTED_MODULE_1__['default'].isString(
                    domain
                  ) && cookie.push('domain=' + domain);

                  secure === true && cookie.push('secure');

                  document.cookie = cookie.join('; ');
                },

                read(name) {
                  const match = document.cookie.match(
                    new RegExp('(^|;\\s*)(' + name + ')=([^;]*)')
                  );
                  return match ? decodeURIComponent(match[3]) : null;
                },

                remove(name) {
                  this.write(name, '', Date.now() - 86400000);
                }
              }
            : // Non-standard browser env (web workers, react-native) lack needed support.
              {
                write() {},
                read() {
                  return null;
                },
                remove() {}
              };

        /***/
      },

    /***/ '../../node_modules/axios/lib/helpers/formDataToJSON.js':
      /*!**************************************************************!*\
  !*** ../../node_modules/axios/lib/helpers/formDataToJSON.js ***!
  \**************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__
          /* harmony export */
        });
        /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ../utils.js */ '../../node_modules/axios/lib/utils.js'
          );

        /**
         * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
         *
         * @param {string} name - The name of the property to get.
         *
         * @returns An array of strings.
         */
        function parsePropPath(name) {
          // foo[x][y][z]
          // foo.x.y.z
          // foo-x-y-z
          // foo x y z
          return _utils_js__WEBPACK_IMPORTED_MODULE_0__['default']
            .matchAll(/\w+|\[(\w*)]/g, name)
            .map(match => {
              return match[0] === '[]' ? '' : match[1] || match[0];
            });
        }

        /**
         * Convert an array to an object.
         *
         * @param {Array<any>} arr - The array to convert to an object.
         *
         * @returns An object with the same keys and values as the array.
         */
        function arrayToObject(arr) {
          const obj = {};
          const keys = Object.keys(arr);
          let i;
          const len = keys.length;
          let key;
          for (i = 0; i < len; i++) {
            key = keys[i];
            obj[key] = arr[key];
          }
          return obj;
        }

        /**
         * It takes a FormData object and returns a JavaScript object
         *
         * @param {string} formData The FormData object to convert to JSON.
         *
         * @returns {Object<string, any> | null} The converted object.
         */
        function formDataToJSON(formData) {
          function buildPath(path, value, target, index) {
            let name = path[index++];

            if (name === '__proto__') return true;

            const isNumericKey = Number.isFinite(+name);
            const isLast = index >= path.length;
            name =
              !name &&
              _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].isArray(target)
                ? target.length
                : name;

            if (isLast) {
              if (
                _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].hasOwnProp(
                  target,
                  name
                )
              ) {
                target[name] = [target[name], value];
              } else {
                target[name] = value;
              }

              return !isNumericKey;
            }

            if (
              !target[name] ||
              !_utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].isObject(
                target[name]
              )
            ) {
              target[name] = [];
            }

            const result = buildPath(path, value, target[name], index);

            if (
              result &&
              _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].isArray(
                target[name]
              )
            ) {
              target[name] = arrayToObject(target[name]);
            }

            return !isNumericKey;
          }

          if (
            _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].isFormData(
              formData
            ) &&
            _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].isFunction(
              formData.entries
            )
          ) {
            const obj = {};

            _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].forEachEntry(
              formData,
              (name, value) => {
                buildPath(parsePropPath(name), value, obj, 0);
              }
            );

            return obj;
          }

          return null;
        }

        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          formDataToJSON;

        /***/
      },

    /***/ '../../node_modules/axios/lib/helpers/isAbsoluteURL.js':
      /*!*************************************************************!*\
  !*** ../../node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
  \*************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => /* binding */ isAbsoluteURL
          /* harmony export */
        });

        /**
         * Determines whether the specified URL is absolute
         *
         * @param {string} url The URL to test
         *
         * @returns {boolean} True if the specified URL is absolute, otherwise false
         */
        function isAbsoluteURL(url) {
          // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
          // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
          // by any combination of letters, digits, plus, period, or hyphen.
          return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
        }

        /***/
      },

    /***/ '../../node_modules/axios/lib/helpers/isAxiosError.js':
      /*!************************************************************!*\
  !*** ../../node_modules/axios/lib/helpers/isAxiosError.js ***!
  \************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => /* binding */ isAxiosError
          /* harmony export */
        });
        /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ./../utils.js */ '../../node_modules/axios/lib/utils.js'
          );

        /**
         * Determines whether the payload is an error thrown by Axios
         *
         * @param {*} payload The value to test
         *
         * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
         */
        function isAxiosError(payload) {
          return (
            _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].isObject(
              payload
            ) && payload.isAxiosError === true
          );
        }

        /***/
      },

    /***/ '../../node_modules/axios/lib/helpers/isURLSameOrigin.js':
      /*!***************************************************************!*\
  !*** ../../node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
  \***************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__
          /* harmony export */
        });
        /* harmony import */ var _platform_index_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ../platform/index.js */ '../../node_modules/axios/lib/platform/index.js'
          );

        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          _platform_index_js__WEBPACK_IMPORTED_MODULE_0__['default']
            .hasStandardBrowserEnv
            ? ((origin, isMSIE) => url => {
                url = new URL(
                  url,
                  _platform_index_js__WEBPACK_IMPORTED_MODULE_0__['default']
                    .origin
                );

                return (
                  origin.protocol === url.protocol &&
                  origin.host === url.host &&
                  (isMSIE || origin.port === url.port)
                );
              })(
                new URL(
                  _platform_index_js__WEBPACK_IMPORTED_MODULE_0__['default']
                    .origin
                ),
                _platform_index_js__WEBPACK_IMPORTED_MODULE_0__['default']
                  .navigator &&
                  /(msie|trident)/i.test(
                    _platform_index_js__WEBPACK_IMPORTED_MODULE_0__['default']
                      .navigator.userAgent
                  )
              )
            : () => true;

        /***/
      },

    /***/ '../../node_modules/axios/lib/helpers/null.js':
      /*!****************************************************!*\
  !*** ../../node_modules/axios/lib/helpers/null.js ***!
  \****************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__
          /* harmony export */
        });
        // eslint-disable-next-line strict
        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = null;

        /***/
      },

    /***/ '../../node_modules/axios/lib/helpers/parseHeaders.js':
      /*!************************************************************!*\
  !*** ../../node_modules/axios/lib/helpers/parseHeaders.js ***!
  \************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__
          /* harmony export */
        });
        /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ./../utils.js */ '../../node_modules/axios/lib/utils.js'
          );

        // RawAxiosHeaders whose duplicates are ignored by node
        // c.f. https://nodejs.org/api/http.html#http_message_headers
        const ignoreDuplicateOf = _utils_js__WEBPACK_IMPORTED_MODULE_0__[
          'default'
        ].toObjectSet([
          'age',
          'authorization',
          'content-length',
          'content-type',
          'etag',
          'expires',
          'from',
          'host',
          'if-modified-since',
          'if-unmodified-since',
          'last-modified',
          'location',
          'max-forwards',
          'proxy-authorization',
          'referer',
          'retry-after',
          'user-agent'
        ]);

        /**
         * Parse headers into an object
         *
         * ```
         * Date: Wed, 27 Aug 2014 08:58:49 GMT
         * Content-Type: application/json
         * Connection: keep-alive
         * Transfer-Encoding: chunked
         * ```
         *
         * @param {String} rawHeaders Headers needing to be parsed
         *
         * @returns {Object} Headers parsed into an object
         */
        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          rawHeaders => {
            const parsed = {};
            let key;
            let val;
            let i;

            rawHeaders &&
              rawHeaders.split('\n').forEach(function parser(line) {
                i = line.indexOf(':');
                key = line.substring(0, i).trim().toLowerCase();
                val = line.substring(i + 1).trim();

                if (!key || (parsed[key] && ignoreDuplicateOf[key])) {
                  return;
                }

                if (key === 'set-cookie') {
                  if (parsed[key]) {
                    parsed[key].push(val);
                  } else {
                    parsed[key] = [val];
                  }
                } else {
                  parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
                }
              });

            return parsed;
          };

        /***/
      },

    /***/ '../../node_modules/axios/lib/helpers/parseProtocol.js':
      /*!*************************************************************!*\
  !*** ../../node_modules/axios/lib/helpers/parseProtocol.js ***!
  \*************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => /* binding */ parseProtocol
          /* harmony export */
        });

        function parseProtocol(url) {
          const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
          return (match && match[1]) || '';
        }

        /***/
      },

    /***/ '../../node_modules/axios/lib/helpers/progressEventReducer.js':
      /*!********************************************************************!*\
  !*** ../../node_modules/axios/lib/helpers/progressEventReducer.js ***!
  \********************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ asyncDecorator: () =>
            /* binding */ asyncDecorator,
          /* harmony export */ progressEventDecorator: () =>
            /* binding */ progressEventDecorator,
          /* harmony export */ progressEventReducer: () =>
            /* binding */ progressEventReducer
          /* harmony export */
        });
        /* harmony import */ var _speedometer_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ./speedometer.js */ '../../node_modules/axios/lib/helpers/speedometer.js'
          );
        /* harmony import */ var _throttle_js__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! ./throttle.js */ '../../node_modules/axios/lib/helpers/throttle.js'
          );
        /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ =
          __webpack_require__(
            /*! ../utils.js */ '../../node_modules/axios/lib/utils.js'
          );

        const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
          let bytesNotified = 0;
          const _speedometer = (0,
          _speedometer_js__WEBPACK_IMPORTED_MODULE_0__['default'])(50, 250);

          return (0, _throttle_js__WEBPACK_IMPORTED_MODULE_1__['default'])(
            e => {
              const loaded = e.loaded;
              const total = e.lengthComputable ? e.total : undefined;
              const progressBytes = loaded - bytesNotified;
              const rate = _speedometer(progressBytes);
              const inRange = loaded <= total;

              bytesNotified = loaded;

              const data = {
                loaded,
                total,
                progress: total ? loaded / total : undefined,
                bytes: progressBytes,
                rate: rate ? rate : undefined,
                estimated:
                  rate && total && inRange
                    ? (total - loaded) / rate
                    : undefined,
                event: e,
                lengthComputable: total != null,
                [isDownloadStream ? 'download' : 'upload']: true
              };

              listener(data);
            },
            freq
          );
        };

        const progressEventDecorator = (total, throttled) => {
          const lengthComputable = total != null;

          return [
            loaded =>
              throttled[0]({
                lengthComputable,
                total,
                loaded
              }),
            throttled[1]
          ];
        };

        const asyncDecorator =
          fn =>
          (...args) =>
            _utils_js__WEBPACK_IMPORTED_MODULE_2__['default'].asap(() =>
              fn(...args)
            );

        /***/
      },

    /***/ '../../node_modules/axios/lib/helpers/resolveConfig.js':
      /*!*************************************************************!*\
  !*** ../../node_modules/axios/lib/helpers/resolveConfig.js ***!
  \*************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__
          /* harmony export */
        });
        /* harmony import */ var _platform_index_js__WEBPACK_IMPORTED_MODULE_5__ =
          __webpack_require__(
            /*! ../platform/index.js */ '../../node_modules/axios/lib/platform/index.js'
          );
        /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ =
          __webpack_require__(
            /*! ../utils.js */ '../../node_modules/axios/lib/utils.js'
          );
        /* harmony import */ var _isURLSameOrigin_js__WEBPACK_IMPORTED_MODULE_6__ =
          __webpack_require__(
            /*! ./isURLSameOrigin.js */ '../../node_modules/axios/lib/helpers/isURLSameOrigin.js'
          );
        /* harmony import */ var _cookies_js__WEBPACK_IMPORTED_MODULE_7__ =
          __webpack_require__(
            /*! ./cookies.js */ '../../node_modules/axios/lib/helpers/cookies.js'
          );
        /* harmony import */ var _core_buildFullPath_js__WEBPACK_IMPORTED_MODULE_3__ =
          __webpack_require__(
            /*! ../core/buildFullPath.js */ '../../node_modules/axios/lib/core/buildFullPath.js'
          );
        /* harmony import */ var _core_mergeConfig_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ../core/mergeConfig.js */ '../../node_modules/axios/lib/core/mergeConfig.js'
          );
        /* harmony import */ var _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! ../core/AxiosHeaders.js */ '../../node_modules/axios/lib/core/AxiosHeaders.js'
          );
        /* harmony import */ var _buildURL_js__WEBPACK_IMPORTED_MODULE_2__ =
          __webpack_require__(
            /*! ./buildURL.js */ '../../node_modules/axios/lib/helpers/buildURL.js'
          );

        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          config => {
            const newConfig = (0,
            _core_mergeConfig_js__WEBPACK_IMPORTED_MODULE_0__['default'])(
              {},
              config
            );

            let {
              data,
              withXSRFToken,
              xsrfHeaderName,
              xsrfCookieName,
              headers,
              auth
            } = newConfig;

            newConfig.headers = headers =
              _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__[
                'default'
              ].from(headers);

            newConfig.url = (0,
            _buildURL_js__WEBPACK_IMPORTED_MODULE_2__['default'])(
              (0,
              _core_buildFullPath_js__WEBPACK_IMPORTED_MODULE_3__['default'])(
                newConfig.baseURL,
                newConfig.url,
                newConfig.allowAbsoluteUrls
              ),
              config.params,
              config.paramsSerializer
            );

            // HTTP basic authentication
            if (auth) {
              headers.set(
                'Authorization',
                'Basic ' +
                  btoa(
                    (auth.username || '') +
                      ':' +
                      (auth.password
                        ? unescape(encodeURIComponent(auth.password))
                        : '')
                  )
              );
            }

            let contentType;

            if (
              _utils_js__WEBPACK_IMPORTED_MODULE_4__['default'].isFormData(data)
            ) {
              if (
                _platform_index_js__WEBPACK_IMPORTED_MODULE_5__['default']
                  .hasStandardBrowserEnv ||
                _platform_index_js__WEBPACK_IMPORTED_MODULE_5__['default']
                  .hasStandardBrowserWebWorkerEnv
              ) {
                headers.setContentType(undefined); // Let the browser set it
              } else if ((contentType = headers.getContentType()) !== false) {
                // fix semicolon duplication issue for ReactNative FormData implementation
                const [type, ...tokens] = contentType
                  ? contentType
                      .split(';')
                      .map(token => token.trim())
                      .filter(Boolean)
                  : [];
                headers.setContentType(
                  [type || 'multipart/form-data', ...tokens].join('; ')
                );
              }
            }

            // Add xsrf header
            // This is only done if running in a standard browser environment.
            // Specifically not if we're in a web worker, or react-native.

            if (
              _platform_index_js__WEBPACK_IMPORTED_MODULE_5__['default']
                .hasStandardBrowserEnv
            ) {
              withXSRFToken &&
                _utils_js__WEBPACK_IMPORTED_MODULE_4__['default'].isFunction(
                  withXSRFToken
                ) &&
                (withXSRFToken = withXSRFToken(newConfig));

              if (
                withXSRFToken ||
                (withXSRFToken !== false &&
                  (0,
                  _isURLSameOrigin_js__WEBPACK_IMPORTED_MODULE_6__['default'])(
                    newConfig.url
                  ))
              ) {
                // Add xsrf header
                const xsrfValue =
                  xsrfHeaderName &&
                  xsrfCookieName &&
                  _cookies_js__WEBPACK_IMPORTED_MODULE_7__['default'].read(
                    xsrfCookieName
                  );

                if (xsrfValue) {
                  headers.set(xsrfHeaderName, xsrfValue);
                }
              }
            }

            return newConfig;
          };

        /***/
      },

    /***/ '../../node_modules/axios/lib/helpers/speedometer.js':
      /*!***********************************************************!*\
  !*** ../../node_modules/axios/lib/helpers/speedometer.js ***!
  \***********************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__
          /* harmony export */
        });

        /**
         * Calculate data maxRate
         * @param {Number} [samplesCount= 10]
         * @param {Number} [min= 1000]
         * @returns {Function}
         */
        function speedometer(samplesCount, min) {
          samplesCount = samplesCount || 10;
          const bytes = new Array(samplesCount);
          const timestamps = new Array(samplesCount);
          let head = 0;
          let tail = 0;
          let firstSampleTS;

          min = min !== undefined ? min : 1000;

          return function push(chunkLength) {
            const now = Date.now();

            const startedAt = timestamps[tail];

            if (!firstSampleTS) {
              firstSampleTS = now;
            }

            bytes[head] = chunkLength;
            timestamps[head] = now;

            let i = tail;
            let bytesCount = 0;

            while (i !== head) {
              bytesCount += bytes[i++];
              i = i % samplesCount;
            }

            head = (head + 1) % samplesCount;

            if (head === tail) {
              tail = (tail + 1) % samplesCount;
            }

            if (now - firstSampleTS < min) {
              return;
            }

            const passed = startedAt && now - startedAt;

            return passed
              ? Math.round((bytesCount * 1000) / passed)
              : undefined;
          };
        }

        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          speedometer;

        /***/
      },

    /***/ '../../node_modules/axios/lib/helpers/spread.js':
      /*!******************************************************!*\
  !*** ../../node_modules/axios/lib/helpers/spread.js ***!
  \******************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => /* binding */ spread
          /* harmony export */
        });

        /**
         * Syntactic sugar for invoking a function and expanding an array for arguments.
         *
         * Common use case would be to use `Function.prototype.apply`.
         *
         *  ```js
         *  function f(x, y, z) {}
         *  var args = [1, 2, 3];
         *  f.apply(null, args);
         *  ```
         *
         * With `spread` this example can be re-written.
         *
         *  ```js
         *  spread(function(x, y, z) {})([1, 2, 3]);
         *  ```
         *
         * @param {Function} callback
         *
         * @returns {Function}
         */
        function spread(callback) {
          return function wrap(arr) {
            return callback.apply(null, arr);
          };
        }

        /***/
      },

    /***/ '../../node_modules/axios/lib/helpers/throttle.js':
      /*!********************************************************!*\
  !*** ../../node_modules/axios/lib/helpers/throttle.js ***!
  \********************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__
          /* harmony export */
        });
        /**
         * Throttle decorator
         * @param {Function} fn
         * @param {Number} freq
         * @return {Function}
         */
        function throttle(fn, freq) {
          let timestamp = 0;
          let threshold = 1000 / freq;
          let lastArgs;
          let timer;

          const invoke = (args, now = Date.now()) => {
            timestamp = now;
            lastArgs = null;
            if (timer) {
              clearTimeout(timer);
              timer = null;
            }
            fn.apply(null, args);
          };

          const throttled = (...args) => {
            const now = Date.now();
            const passed = now - timestamp;
            if (passed >= threshold) {
              invoke(args, now);
            } else {
              lastArgs = args;
              if (!timer) {
                timer = setTimeout(() => {
                  timer = null;
                  invoke(lastArgs);
                }, threshold - passed);
              }
            }
          };

          const flush = () => lastArgs && invoke(lastArgs);

          return [throttled, flush];
        }

        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          throttle;

        /***/
      },

    /***/ '../../node_modules/axios/lib/helpers/toFormData.js':
      /*!**********************************************************!*\
  !*** ../../node_modules/axios/lib/helpers/toFormData.js ***!
  \**********************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__
          /* harmony export */
        });
        /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ../utils.js */ '../../node_modules/axios/lib/utils.js'
          );
        /* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__ =
          __webpack_require__(
            /*! ../core/AxiosError.js */ '../../node_modules/axios/lib/core/AxiosError.js'
          );
        /* harmony import */ var _platform_node_classes_FormData_js__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! ../platform/node/classes/FormData.js */ '../../node_modules/axios/lib/helpers/null.js'
          );

        // temporary hotfix to avoid circular references until AxiosURLSearchParams is refactored

        /**
         * Determines if the given thing is a array or js object.
         *
         * @param {string} thing - The object or array to be visited.
         *
         * @returns {boolean}
         */
        function isVisitable(thing) {
          return (
            _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].isPlainObject(
              thing
            ) ||
            _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].isArray(thing)
          );
        }

        /**
         * It removes the brackets from the end of a string
         *
         * @param {string} key - The key of the parameter.
         *
         * @returns {string} the key without the brackets.
         */
        function removeBrackets(key) {
          return _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].endsWith(
            key,
            '[]'
          )
            ? key.slice(0, -2)
            : key;
        }

        /**
         * It takes a path, a key, and a boolean, and returns a string
         *
         * @param {string} path - The path to the current key.
         * @param {string} key - The key of the current object being iterated over.
         * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
         *
         * @returns {string} The path to the current key.
         */
        function renderKey(path, key, dots) {
          if (!path) return key;
          return path
            .concat(key)
            .map(function each(token, i) {
              // eslint-disable-next-line no-param-reassign
              token = removeBrackets(token);
              return !dots && i ? '[' + token + ']' : token;
            })
            .join(dots ? '.' : '');
        }

        /**
         * If the array is an array and none of its elements are visitable, then it's a flat array.
         *
         * @param {Array<any>} arr - The array to check
         *
         * @returns {boolean}
         */
        function isFlatArray(arr) {
          return (
            _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].isArray(arr) &&
            !arr.some(isVisitable)
          );
        }

        const predicates = _utils_js__WEBPACK_IMPORTED_MODULE_0__[
          'default'
        ].toFlatObject(
          _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'],
          {},
          null,
          function filter(prop) {
            return /^is[A-Z]/.test(prop);
          }
        );

        /**
         * Convert a data object to FormData
         *
         * @param {Object} obj
         * @param {?Object} [formData]
         * @param {?Object} [options]
         * @param {Function} [options.visitor]
         * @param {Boolean} [options.metaTokens = true]
         * @param {Boolean} [options.dots = false]
         * @param {?Boolean} [options.indexes = false]
         *
         * @returns {Object}
         **/

        /**
         * It converts an object into a FormData object
         *
         * @param {Object<any, any>} obj - The object to convert to form data.
         * @param {string} formData - The FormData object to append to.
         * @param {Object<string, any>} options
         *
         * @returns
         */
        function toFormData(obj, formData, options) {
          if (
            !_utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].isObject(obj)
          ) {
            throw new TypeError('target must be an object');
          }

          // eslint-disable-next-line no-param-reassign
          formData =
            formData ||
            new (
              _platform_node_classes_FormData_js__WEBPACK_IMPORTED_MODULE_1__[
                'default'
              ] || FormData
            )();

          // eslint-disable-next-line no-param-reassign
          options = _utils_js__WEBPACK_IMPORTED_MODULE_0__[
            'default'
          ].toFlatObject(
            options,
            {
              metaTokens: true,
              dots: false,
              indexes: false
            },
            false,
            function defined(option, source) {
              // eslint-disable-next-line no-eq-null,eqeqeq
              return !_utils_js__WEBPACK_IMPORTED_MODULE_0__[
                'default'
              ].isUndefined(source[option]);
            }
          );

          const metaTokens = options.metaTokens;
          // eslint-disable-next-line no-use-before-define
          const visitor = options.visitor || defaultVisitor;
          const dots = options.dots;
          const indexes = options.indexes;
          const _Blob = options.Blob || (typeof Blob !== 'undefined' && Blob);
          const useBlob =
            _Blob &&
            _utils_js__WEBPACK_IMPORTED_MODULE_0__[
              'default'
            ].isSpecCompliantForm(formData);

          if (
            !_utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].isFunction(
              visitor
            )
          ) {
            throw new TypeError('visitor must be a function');
          }

          function convertValue(value) {
            if (value === null) return '';

            if (
              _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].isDate(value)
            ) {
              return value.toISOString();
            }

            if (
              !useBlob &&
              _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].isBlob(value)
            ) {
              throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__[
                'default'
              ]('Blob is not supported. Use a Buffer instead.');
            }

            if (
              _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].isArrayBuffer(
                value
              ) ||
              _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].isTypedArray(
                value
              )
            ) {
              return useBlob && typeof Blob === 'function'
                ? new Blob([value])
                : Buffer.from(value);
            }

            return value;
          }

          /**
           * Default visitor.
           *
           * @param {*} value
           * @param {String|Number} key
           * @param {Array<String|Number>} path
           * @this {FormData}
           *
           * @returns {boolean} return true to visit the each prop of the value recursively
           */
          function defaultVisitor(value, key, path) {
            let arr = value;

            if (value && !path && typeof value === 'object') {
              if (
                _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].endsWith(
                  key,
                  '{}'
                )
              ) {
                // eslint-disable-next-line no-param-reassign
                key = metaTokens ? key : key.slice(0, -2);
                // eslint-disable-next-line no-param-reassign
                value = JSON.stringify(value);
              } else if (
                (_utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].isArray(
                  value
                ) &&
                  isFlatArray(value)) ||
                ((_utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].isFileList(
                  value
                ) ||
                  _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].endsWith(
                    key,
                    '[]'
                  )) &&
                  (arr =
                    _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].toArray(
                      value
                    )))
              ) {
                // eslint-disable-next-line no-param-reassign
                key = removeBrackets(key);

                arr.forEach(function each(el, index) {
                  !(
                    _utils_js__WEBPACK_IMPORTED_MODULE_0__[
                      'default'
                    ].isUndefined(el) || el === null
                  ) &&
                    formData.append(
                      // eslint-disable-next-line no-nested-ternary
                      indexes === true
                        ? renderKey([key], index, dots)
                        : indexes === null
                          ? key
                          : key + '[]',
                      convertValue(el)
                    );
                });
                return false;
              }
            }

            if (isVisitable(value)) {
              return true;
            }

            formData.append(renderKey(path, key, dots), convertValue(value));

            return false;
          }

          const stack = [];

          const exposedHelpers = Object.assign(predicates, {
            defaultVisitor,
            convertValue,
            isVisitable
          });

          function build(value, path) {
            if (
              _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].isUndefined(
                value
              )
            )
              return;

            if (stack.indexOf(value) !== -1) {
              throw Error('Circular reference detected in ' + path.join('.'));
            }

            stack.push(value);

            _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].forEach(
              value,
              function each(el, key) {
                const result =
                  !(
                    _utils_js__WEBPACK_IMPORTED_MODULE_0__[
                      'default'
                    ].isUndefined(el) || el === null
                  ) &&
                  visitor.call(
                    formData,
                    el,
                    _utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].isString(
                      key
                    )
                      ? key.trim()
                      : key,
                    path,
                    exposedHelpers
                  );

                if (result === true) {
                  build(el, path ? path.concat(key) : [key]);
                }
              }
            );

            stack.pop();
          }

          if (
            !_utils_js__WEBPACK_IMPORTED_MODULE_0__['default'].isObject(obj)
          ) {
            throw new TypeError('data must be an object');
          }

          build(obj);

          return formData;
        }

        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          toFormData;

        /***/
      },

    /***/ '../../node_modules/axios/lib/helpers/toURLEncodedForm.js':
      /*!****************************************************************!*\
  !*** ../../node_modules/axios/lib/helpers/toURLEncodedForm.js ***!
  \****************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => /* binding */ toURLEncodedForm
          /* harmony export */
        });
        /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ =
          __webpack_require__(
            /*! ../utils.js */ '../../node_modules/axios/lib/utils.js'
          );
        /* harmony import */ var _toFormData_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ./toFormData.js */ '../../node_modules/axios/lib/helpers/toFormData.js'
          );
        /* harmony import */ var _platform_index_js__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! ../platform/index.js */ '../../node_modules/axios/lib/platform/index.js'
          );

        function toURLEncodedForm(data, options) {
          return (0, _toFormData_js__WEBPACK_IMPORTED_MODULE_0__['default'])(
            data,
            new _platform_index_js__WEBPACK_IMPORTED_MODULE_1__[
              'default'
            ].classes.URLSearchParams(),
            Object.assign(
              {
                visitor: function (value, key, path, helpers) {
                  if (
                    _platform_index_js__WEBPACK_IMPORTED_MODULE_1__['default']
                      .isNode &&
                    _utils_js__WEBPACK_IMPORTED_MODULE_2__['default'].isBuffer(
                      value
                    )
                  ) {
                    this.append(key, value.toString('base64'));
                    return false;
                  }

                  return helpers.defaultVisitor.apply(this, arguments);
                }
              },
              options
            )
          );
        }

        /***/
      },

    /***/ '../../node_modules/axios/lib/helpers/trackStream.js':
      /*!***********************************************************!*\
  !*** ../../node_modules/axios/lib/helpers/trackStream.js ***!
  \***********************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ readBytes: () => /* binding */ readBytes,
          /* harmony export */ streamChunk: () => /* binding */ streamChunk,
          /* harmony export */ trackStream: () => /* binding */ trackStream
          /* harmony export */
        });

        const streamChunk = function* (chunk, chunkSize) {
          let len = chunk.byteLength;

          if (!chunkSize || len < chunkSize) {
            yield chunk;
            return;
          }

          let pos = 0;
          let end;

          while (pos < len) {
            end = pos + chunkSize;
            yield chunk.slice(pos, end);
            pos = end;
          }
        };

        const readBytes = async function* (iterable, chunkSize) {
          for await (const chunk of readStream(iterable)) {
            yield* streamChunk(chunk, chunkSize);
          }
        };

        const readStream = async function* (stream) {
          if (stream[Symbol.asyncIterator]) {
            yield* stream;
            return;
          }

          const reader = stream.getReader();
          try {
            for (;;) {
              const { done, value } = await reader.read();
              if (done) {
                break;
              }
              yield value;
            }
          } finally {
            await reader.cancel();
          }
        };

        const trackStream = (stream, chunkSize, onProgress, onFinish) => {
          const iterator = readBytes(stream, chunkSize);

          let bytes = 0;
          let done;
          let _onFinish = e => {
            if (!done) {
              done = true;
              onFinish && onFinish(e);
            }
          };

          return new ReadableStream(
            {
              async pull(controller) {
                try {
                  const { done, value } = await iterator.next();

                  if (done) {
                    _onFinish();
                    controller.close();
                    return;
                  }

                  let len = value.byteLength;
                  if (onProgress) {
                    let loadedBytes = (bytes += len);
                    onProgress(loadedBytes);
                  }
                  controller.enqueue(new Uint8Array(value));
                } catch (err) {
                  _onFinish(err);
                  throw err;
                }
              },
              cancel(reason) {
                _onFinish(reason);
                return iterator.return();
              }
            },
            {
              highWaterMark: 2
            }
          );
        };

        /***/
      },

    /***/ '../../node_modules/axios/lib/helpers/validator.js':
      /*!*********************************************************!*\
  !*** ../../node_modules/axios/lib/helpers/validator.js ***!
  \*********************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__
          /* harmony export */
        });
        /* harmony import */ var _env_data_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ../env/data.js */ '../../node_modules/axios/lib/env/data.js'
          );
        /* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! ../core/AxiosError.js */ '../../node_modules/axios/lib/core/AxiosError.js'
          );

        const validators = {};

        // eslint-disable-next-line func-names
        ['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(
          (type, i) => {
            validators[type] = function validator(thing) {
              return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
            };
          }
        );

        const deprecatedWarnings = {};

        /**
         * Transitional option validator
         *
         * @param {function|boolean?} validator - set to false if the transitional option has been removed
         * @param {string?} version - deprecated version / removed since version
         * @param {string?} message - some message with additional info
         *
         * @returns {function}
         */
        validators.transitional = function transitional(
          validator,
          version,
          message
        ) {
          function formatMessage(opt, desc) {
            return (
              '[Axios v' +
              _env_data_js__WEBPACK_IMPORTED_MODULE_0__.VERSION +
              "] Transitional option '" +
              opt +
              "'" +
              desc +
              (message ? '. ' + message : '')
            );
          }

          // eslint-disable-next-line func-names
          return (value, opt, opts) => {
            if (validator === false) {
              throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__[
                'default'
              ](
                formatMessage(
                  opt,
                  ' has been removed' + (version ? ' in ' + version : '')
                ),
                _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__['default']
                  .ERR_DEPRECATED
              );
            }

            if (version && !deprecatedWarnings[opt]) {
              deprecatedWarnings[opt] = true;
              // eslint-disable-next-line no-console
              console.warn(
                formatMessage(
                  opt,
                  ' has been deprecated since v' +
                    version +
                    ' and will be removed in the near future'
                )
              );
            }

            return validator ? validator(value, opt, opts) : true;
          };
        };

        validators.spelling = function spelling(correctSpelling) {
          return (value, opt) => {
            // eslint-disable-next-line no-console
            console.warn(
              `${opt} is likely a misspelling of ${correctSpelling}`
            );
            return true;
          };
        };

        /**
         * Assert object's properties type
         *
         * @param {object} options
         * @param {object} schema
         * @param {boolean?} allowUnknown
         *
         * @returns {object}
         */

        function assertOptions(options, schema, allowUnknown) {
          if (typeof options !== 'object') {
            throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__[
              'default'
            ](
              'options must be an object',
              _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__['default']
                .ERR_BAD_OPTION_VALUE
            );
          }
          const keys = Object.keys(options);
          let i = keys.length;
          while (i-- > 0) {
            const opt = keys[i];
            const validator = schema[opt];
            if (validator) {
              const value = options[opt];
              const result =
                value === undefined || validator(value, opt, options);
              if (result !== true) {
                throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__[
                  'default'
                ](
                  'option ' + opt + ' must be ' + result,
                  _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__['default']
                    .ERR_BAD_OPTION_VALUE
                );
              }
              continue;
            }
            if (allowUnknown !== true) {
              throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__[
                'default'
              ](
                'Unknown option ' + opt,
                _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__['default']
                  .ERR_BAD_OPTION
              );
            }
          }
        }

        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = {
          assertOptions,
          validators
        };

        /***/
      },

    /***/ '../../node_modules/axios/lib/platform/browser/classes/Blob.js':
      /*!*********************************************************************!*\
  !*** ../../node_modules/axios/lib/platform/browser/classes/Blob.js ***!
  \*********************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__
          /* harmony export */
        });

        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          typeof Blob !== 'undefined' ? Blob : null;

        /***/
      },

    /***/ '../../node_modules/axios/lib/platform/browser/classes/FormData.js':
      /*!*************************************************************************!*\
  !*** ../../node_modules/axios/lib/platform/browser/classes/FormData.js ***!
  \*************************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__
          /* harmony export */
        });

        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          typeof FormData !== 'undefined' ? FormData : null;

        /***/
      },

    /***/ '../../node_modules/axios/lib/platform/browser/classes/URLSearchParams.js':
      /*!********************************************************************************!*\
  !*** ../../node_modules/axios/lib/platform/browser/classes/URLSearchParams.js ***!
  \********************************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__
          /* harmony export */
        });
        /* harmony import */ var _helpers_AxiosURLSearchParams_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ../../../helpers/AxiosURLSearchParams.js */ '../../node_modules/axios/lib/helpers/AxiosURLSearchParams.js'
          );

        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          typeof URLSearchParams !== 'undefined'
            ? URLSearchParams
            : _helpers_AxiosURLSearchParams_js__WEBPACK_IMPORTED_MODULE_0__[
                'default'
              ];

        /***/
      },

    /***/ '../../node_modules/axios/lib/platform/browser/index.js':
      /*!**************************************************************!*\
  !*** ../../node_modules/axios/lib/platform/browser/index.js ***!
  \**************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__
          /* harmony export */
        });
        /* harmony import */ var _classes_URLSearchParams_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ./classes/URLSearchParams.js */ '../../node_modules/axios/lib/platform/browser/classes/URLSearchParams.js'
          );
        /* harmony import */ var _classes_FormData_js__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! ./classes/FormData.js */ '../../node_modules/axios/lib/platform/browser/classes/FormData.js'
          );
        /* harmony import */ var _classes_Blob_js__WEBPACK_IMPORTED_MODULE_2__ =
          __webpack_require__(
            /*! ./classes/Blob.js */ '../../node_modules/axios/lib/platform/browser/classes/Blob.js'
          );

        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = {
          isBrowser: true,
          classes: {
            URLSearchParams:
              _classes_URLSearchParams_js__WEBPACK_IMPORTED_MODULE_0__[
                'default'
              ],
            FormData:
              _classes_FormData_js__WEBPACK_IMPORTED_MODULE_1__['default'],
            Blob: _classes_Blob_js__WEBPACK_IMPORTED_MODULE_2__['default']
          },
          protocols: ['http', 'https', 'file', 'blob', 'url', 'data']
        };

        /***/
      },

    /***/ '../../node_modules/axios/lib/platform/common/utils.js':
      /*!*************************************************************!*\
  !*** ../../node_modules/axios/lib/platform/common/utils.js ***!
  \*************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ hasBrowserEnv: () => /* binding */ hasBrowserEnv,
          /* harmony export */ hasStandardBrowserEnv: () =>
            /* binding */ hasStandardBrowserEnv,
          /* harmony export */ hasStandardBrowserWebWorkerEnv: () =>
            /* binding */ hasStandardBrowserWebWorkerEnv,
          /* harmony export */ navigator: () => /* binding */ _navigator,
          /* harmony export */ origin: () => /* binding */ origin
          /* harmony export */
        });
        const hasBrowserEnv =
          typeof window !== 'undefined' && typeof document !== 'undefined';

        const _navigator =
          (typeof navigator === 'object' && navigator) || undefined;

        /**
         * Determine if we're running in a standard browser environment
         *
         * This allows axios to run in a web worker, and react-native.
         * Both environments support XMLHttpRequest, but not fully standard globals.
         *
         * web workers:
         *  typeof window -> undefined
         *  typeof document -> undefined
         *
         * react-native:
         *  navigator.product -> 'ReactNative'
         * nativescript
         *  navigator.product -> 'NativeScript' or 'NS'
         *
         * @returns {boolean}
         */
        const hasStandardBrowserEnv =
          hasBrowserEnv &&
          (!_navigator ||
            ['ReactNative', 'NativeScript', 'NS'].indexOf(_navigator.product) <
              0);

        /**
         * Determine if we're running in a standard browser webWorker environment
         *
         * Although the `isStandardBrowserEnv` method indicates that
         * `allows axios to run in a web worker`, the WebWorker will still be
         * filtered out due to its judgment standard
         * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
         * This leads to a problem when axios post `FormData` in webWorker
         */
        const hasStandardBrowserWebWorkerEnv = (() => {
          return (
            typeof WorkerGlobalScope !== 'undefined' &&
            // eslint-disable-next-line no-undef
            self instanceof WorkerGlobalScope &&
            typeof self.importScripts === 'function'
          );
        })();

        const origin =
          (hasBrowserEnv && window.location.href) || 'http://localhost';

        /***/
      },

    /***/ '../../node_modules/axios/lib/platform/index.js':
      /*!******************************************************!*\
  !*** ../../node_modules/axios/lib/platform/index.js ***!
  \******************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__
          /* harmony export */
        });
        /* harmony import */ var _node_index_js__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! ./node/index.js */ '../../node_modules/axios/lib/platform/browser/index.js'
          );
        /* harmony import */ var _common_utils_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ./common/utils.js */ '../../node_modules/axios/lib/platform/common/utils.js'
          );

        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = {
          ..._common_utils_js__WEBPACK_IMPORTED_MODULE_0__,
          ..._node_index_js__WEBPACK_IMPORTED_MODULE_1__['default']
        };

        /***/
      },

    /***/ '../../node_modules/axios/lib/utils.js':
      /*!*********************************************!*\
  !*** ../../node_modules/axios/lib/utils.js ***!
  \*********************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__
          /* harmony export */
        });
        /* harmony import */ var _helpers_bind_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ./helpers/bind.js */ '../../node_modules/axios/lib/helpers/bind.js'
          );
        /* provided dependency */ var process = __webpack_require__(
          /*! process/browser */ '../../node_modules/process/browser.js'
        );

        // utils is a library of generic helper functions non-specific to axios

        const { toString } = Object.prototype;
        const { getPrototypeOf } = Object;

        const kindOf = (cache => thing => {
          const str = toString.call(thing);
          return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
        })(Object.create(null));

        const kindOfTest = type => {
          type = type.toLowerCase();
          return thing => kindOf(thing) === type;
        };

        const typeOfTest = type => thing => typeof thing === type;

        /**
         * Determine if a value is an Array
         *
         * @param {Object} val The value to test
         *
         * @returns {boolean} True if value is an Array, otherwise false
         */
        const { isArray } = Array;

        /**
         * Determine if a value is undefined
         *
         * @param {*} val The value to test
         *
         * @returns {boolean} True if the value is undefined, otherwise false
         */
        const isUndefined = typeOfTest('undefined');

        /**
         * Determine if a value is a Buffer
         *
         * @param {*} val The value to test
         *
         * @returns {boolean} True if value is a Buffer, otherwise false
         */
        function isBuffer(val) {
          return (
            val !== null &&
            !isUndefined(val) &&
            val.constructor !== null &&
            !isUndefined(val.constructor) &&
            isFunction(val.constructor.isBuffer) &&
            val.constructor.isBuffer(val)
          );
        }

        /**
         * Determine if a value is an ArrayBuffer
         *
         * @param {*} val The value to test
         *
         * @returns {boolean} True if value is an ArrayBuffer, otherwise false
         */
        const isArrayBuffer = kindOfTest('ArrayBuffer');

        /**
         * Determine if a value is a view on an ArrayBuffer
         *
         * @param {*} val The value to test
         *
         * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
         */
        function isArrayBufferView(val) {
          let result;
          if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
            result = ArrayBuffer.isView(val);
          } else {
            result = val && val.buffer && isArrayBuffer(val.buffer);
          }
          return result;
        }

        /**
         * Determine if a value is a String
         *
         * @param {*} val The value to test
         *
         * @returns {boolean} True if value is a String, otherwise false
         */
        const isString = typeOfTest('string');

        /**
         * Determine if a value is a Function
         *
         * @param {*} val The value to test
         * @returns {boolean} True if value is a Function, otherwise false
         */
        const isFunction = typeOfTest('function');

        /**
         * Determine if a value is a Number
         *
         * @param {*} val The value to test
         *
         * @returns {boolean} True if value is a Number, otherwise false
         */
        const isNumber = typeOfTest('number');

        /**
         * Determine if a value is an Object
         *
         * @param {*} thing The value to test
         *
         * @returns {boolean} True if value is an Object, otherwise false
         */
        const isObject = thing => thing !== null && typeof thing === 'object';

        /**
         * Determine if a value is a Boolean
         *
         * @param {*} thing The value to test
         * @returns {boolean} True if value is a Boolean, otherwise false
         */
        const isBoolean = thing => thing === true || thing === false;

        /**
         * Determine if a value is a plain Object
         *
         * @param {*} val The value to test
         *
         * @returns {boolean} True if value is a plain Object, otherwise false
         */
        const isPlainObject = val => {
          if (kindOf(val) !== 'object') {
            return false;
          }

          const prototype = getPrototypeOf(val);
          return (
            (prototype === null ||
              prototype === Object.prototype ||
              Object.getPrototypeOf(prototype) === null) &&
            !(Symbol.toStringTag in val) &&
            !(Symbol.iterator in val)
          );
        };

        /**
         * Determine if a value is a Date
         *
         * @param {*} val The value to test
         *
         * @returns {boolean} True if value is a Date, otherwise false
         */
        const isDate = kindOfTest('Date');

        /**
         * Determine if a value is a File
         *
         * @param {*} val The value to test
         *
         * @returns {boolean} True if value is a File, otherwise false
         */
        const isFile = kindOfTest('File');

        /**
         * Determine if a value is a Blob
         *
         * @param {*} val The value to test
         *
         * @returns {boolean} True if value is a Blob, otherwise false
         */
        const isBlob = kindOfTest('Blob');

        /**
         * Determine if a value is a FileList
         *
         * @param {*} val The value to test
         *
         * @returns {boolean} True if value is a File, otherwise false
         */
        const isFileList = kindOfTest('FileList');

        /**
         * Determine if a value is a Stream
         *
         * @param {*} val The value to test
         *
         * @returns {boolean} True if value is a Stream, otherwise false
         */
        const isStream = val => isObject(val) && isFunction(val.pipe);

        /**
         * Determine if a value is a FormData
         *
         * @param {*} thing The value to test
         *
         * @returns {boolean} True if value is an FormData, otherwise false
         */
        const isFormData = thing => {
          let kind;
          return (
            thing &&
            ((typeof FormData === 'function' && thing instanceof FormData) ||
              (isFunction(thing.append) &&
                ((kind = kindOf(thing)) === 'formdata' ||
                  // detect form-data instance
                  (kind === 'object' &&
                    isFunction(thing.toString) &&
                    thing.toString() === '[object FormData]'))))
          );
        };

        /**
         * Determine if a value is a URLSearchParams object
         *
         * @param {*} val The value to test
         *
         * @returns {boolean} True if value is a URLSearchParams object, otherwise false
         */
        const isURLSearchParams = kindOfTest('URLSearchParams');

        const [isReadableStream, isRequest, isResponse, isHeaders] = [
          'ReadableStream',
          'Request',
          'Response',
          'Headers'
        ].map(kindOfTest);

        /**
         * Trim excess whitespace off the beginning and end of a string
         *
         * @param {String} str The String to trim
         *
         * @returns {String} The String freed of excess whitespace
         */
        const trim = str =>
          str.trim
            ? str.trim()
            : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

        /**
         * Iterate over an Array or an Object invoking a function for each item.
         *
         * If `obj` is an Array callback will be called passing
         * the value, index, and complete array for each item.
         *
         * If 'obj' is an Object callback will be called passing
         * the value, key, and complete object for each property.
         *
         * @param {Object|Array} obj The object to iterate
         * @param {Function} fn The callback to invoke for each item
         *
         * @param {Boolean} [allOwnKeys = false]
         * @returns {any}
         */
        function forEach(obj, fn, { allOwnKeys = false } = {}) {
          // Don't bother if no value provided
          if (obj === null || typeof obj === 'undefined') {
            return;
          }

          let i;
          let l;

          // Force an array if not already something iterable
          if (typeof obj !== 'object') {
            /*eslint no-param-reassign:0*/
            obj = [obj];
          }

          if (isArray(obj)) {
            // Iterate over array values
            for (i = 0, l = obj.length; i < l; i++) {
              fn.call(null, obj[i], i, obj);
            }
          } else {
            // Iterate over object keys
            const keys = allOwnKeys
              ? Object.getOwnPropertyNames(obj)
              : Object.keys(obj);
            const len = keys.length;
            let key;

            for (i = 0; i < len; i++) {
              key = keys[i];
              fn.call(null, obj[key], key, obj);
            }
          }
        }

        function findKey(obj, key) {
          key = key.toLowerCase();
          const keys = Object.keys(obj);
          let i = keys.length;
          let _key;
          while (i-- > 0) {
            _key = keys[i];
            if (key === _key.toLowerCase()) {
              return _key;
            }
          }
          return null;
        }

        const _global = (() => {
          /*eslint no-undef:0*/
          if (typeof globalThis !== 'undefined') return globalThis;
          return typeof self !== 'undefined'
            ? self
            : typeof window !== 'undefined'
              ? window
              : __webpack_require__.g;
        })();

        const isContextDefined = context =>
          !isUndefined(context) && context !== _global;

        /**
         * Accepts varargs expecting each argument to be an object, then
         * immutably merges the properties of each object and returns result.
         *
         * When multiple objects contain the same key the later object in
         * the arguments list will take precedence.
         *
         * Example:
         *
         * ```js
         * var result = merge({foo: 123}, {foo: 456});
         * console.log(result.foo); // outputs 456
         * ```
         *
         * @param {Object} obj1 Object to merge
         *
         * @returns {Object} Result of all merge properties
         */
        function merge(/* obj1, obj2, obj3, ... */) {
          const { caseless } = (isContextDefined(this) && this) || {};
          const result = {};
          const assignValue = (val, key) => {
            const targetKey = (caseless && findKey(result, key)) || key;
            if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
              result[targetKey] = merge(result[targetKey], val);
            } else if (isPlainObject(val)) {
              result[targetKey] = merge({}, val);
            } else if (isArray(val)) {
              result[targetKey] = val.slice();
            } else {
              result[targetKey] = val;
            }
          };

          for (let i = 0, l = arguments.length; i < l; i++) {
            arguments[i] && forEach(arguments[i], assignValue);
          }
          return result;
        }

        /**
         * Extends object a by mutably adding to it the properties of object b.
         *
         * @param {Object} a The object to be extended
         * @param {Object} b The object to copy properties from
         * @param {Object} thisArg The object to bind function to
         *
         * @param {Boolean} [allOwnKeys]
         * @returns {Object} The resulting value of object a
         */
        const extend = (a, b, thisArg, { allOwnKeys } = {}) => {
          forEach(
            b,
            (val, key) => {
              if (thisArg && isFunction(val)) {
                a[key] = (0,
                _helpers_bind_js__WEBPACK_IMPORTED_MODULE_0__['default'])(
                  val,
                  thisArg
                );
              } else {
                a[key] = val;
              }
            },
            { allOwnKeys }
          );
          return a;
        };

        /**
         * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
         *
         * @param {string} content with BOM
         *
         * @returns {string} content value without BOM
         */
        const stripBOM = content => {
          if (content.charCodeAt(0) === 0xfeff) {
            content = content.slice(1);
          }
          return content;
        };

        /**
         * Inherit the prototype methods from one constructor into another
         * @param {function} constructor
         * @param {function} superConstructor
         * @param {object} [props]
         * @param {object} [descriptors]
         *
         * @returns {void}
         */
        const inherits = (
          constructor,
          superConstructor,
          props,
          descriptors
        ) => {
          constructor.prototype = Object.create(
            superConstructor.prototype,
            descriptors
          );
          constructor.prototype.constructor = constructor;
          Object.defineProperty(constructor, 'super', {
            value: superConstructor.prototype
          });
          props && Object.assign(constructor.prototype, props);
        };

        /**
         * Resolve object with deep prototype chain to a flat object
         * @param {Object} sourceObj source object
         * @param {Object} [destObj]
         * @param {Function|Boolean} [filter]
         * @param {Function} [propFilter]
         *
         * @returns {Object}
         */
        const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
          let props;
          let i;
          let prop;
          const merged = {};

          destObj = destObj || {};
          // eslint-disable-next-line no-eq-null,eqeqeq
          if (sourceObj == null) return destObj;

          do {
            props = Object.getOwnPropertyNames(sourceObj);
            i = props.length;
            while (i-- > 0) {
              prop = props[i];
              if (
                (!propFilter || propFilter(prop, sourceObj, destObj)) &&
                !merged[prop]
              ) {
                destObj[prop] = sourceObj[prop];
                merged[prop] = true;
              }
            }
            sourceObj = filter !== false && getPrototypeOf(sourceObj);
          } while (
            sourceObj &&
            (!filter || filter(sourceObj, destObj)) &&
            sourceObj !== Object.prototype
          );

          return destObj;
        };

        /**
         * Determines whether a string ends with the characters of a specified string
         *
         * @param {String} str
         * @param {String} searchString
         * @param {Number} [position= 0]
         *
         * @returns {boolean}
         */
        const endsWith = (str, searchString, position) => {
          str = String(str);
          if (position === undefined || position > str.length) {
            position = str.length;
          }
          position -= searchString.length;
          const lastIndex = str.indexOf(searchString, position);
          return lastIndex !== -1 && lastIndex === position;
        };

        /**
         * Returns new array from array like object or null if failed
         *
         * @param {*} [thing]
         *
         * @returns {?Array}
         */
        const toArray = thing => {
          if (!thing) return null;
          if (isArray(thing)) return thing;
          let i = thing.length;
          if (!isNumber(i)) return null;
          const arr = new Array(i);
          while (i-- > 0) {
            arr[i] = thing[i];
          }
          return arr;
        };

        /**
         * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
         * thing passed in is an instance of Uint8Array
         *
         * @param {TypedArray}
         *
         * @returns {Array}
         */
        // eslint-disable-next-line func-names
        const isTypedArray = (TypedArray => {
          // eslint-disable-next-line func-names
          return thing => {
            return TypedArray && thing instanceof TypedArray;
          };
        })(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));

        /**
         * For each entry in the object, call the function with the key and value.
         *
         * @param {Object<any, any>} obj - The object to iterate over.
         * @param {Function} fn - The function to call for each entry.
         *
         * @returns {void}
         */
        const forEachEntry = (obj, fn) => {
          const generator = obj && obj[Symbol.iterator];

          const iterator = generator.call(obj);

          let result;

          while ((result = iterator.next()) && !result.done) {
            const pair = result.value;
            fn.call(obj, pair[0], pair[1]);
          }
        };

        /**
         * It takes a regular expression and a string, and returns an array of all the matches
         *
         * @param {string} regExp - The regular expression to match against.
         * @param {string} str - The string to search.
         *
         * @returns {Array<boolean>}
         */
        const matchAll = (regExp, str) => {
          let matches;
          const arr = [];

          while ((matches = regExp.exec(str)) !== null) {
            arr.push(matches);
          }

          return arr;
        };

        /* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */
        const isHTMLForm = kindOfTest('HTMLFormElement');

        const toCamelCase = str => {
          return str
            .toLowerCase()
            .replace(/[-_\s]([a-z\d])(\w*)/g, function replacer(m, p1, p2) {
              return p1.toUpperCase() + p2;
            });
        };

        /* Creating a function that will check if an object has a property. */
        const hasOwnProperty = (
          ({ hasOwnProperty }) =>
          (obj, prop) =>
            hasOwnProperty.call(obj, prop)
        )(Object.prototype);

        /**
         * Determine if a value is a RegExp object
         *
         * @param {*} val The value to test
         *
         * @returns {boolean} True if value is a RegExp object, otherwise false
         */
        const isRegExp = kindOfTest('RegExp');

        const reduceDescriptors = (obj, reducer) => {
          const descriptors = Object.getOwnPropertyDescriptors(obj);
          const reducedDescriptors = {};

          forEach(descriptors, (descriptor, name) => {
            let ret;
            if ((ret = reducer(descriptor, name, obj)) !== false) {
              reducedDescriptors[name] = ret || descriptor;
            }
          });

          Object.defineProperties(obj, reducedDescriptors);
        };

        /**
         * Makes all methods read-only
         * @param {Object} obj
         */

        const freezeMethods = obj => {
          reduceDescriptors(obj, (descriptor, name) => {
            // skip restricted props in strict mode
            if (
              isFunction(obj) &&
              ['arguments', 'caller', 'callee'].indexOf(name) !== -1
            ) {
              return false;
            }

            const value = obj[name];

            if (!isFunction(value)) return;

            descriptor.enumerable = false;

            if ('writable' in descriptor) {
              descriptor.writable = false;
              return;
            }

            if (!descriptor.set) {
              descriptor.set = () => {
                throw Error("Can not rewrite read-only method '" + name + "'");
              };
            }
          });
        };

        const toObjectSet = (arrayOrString, delimiter) => {
          const obj = {};

          const define = arr => {
            arr.forEach(value => {
              obj[value] = true;
            });
          };

          isArray(arrayOrString)
            ? define(arrayOrString)
            : define(String(arrayOrString).split(delimiter));

          return obj;
        };

        const noop = () => {};

        const toFiniteNumber = (value, defaultValue) => {
          return value != null && Number.isFinite((value = +value))
            ? value
            : defaultValue;
        };

        /**
         * If the thing is a FormData object, return true, otherwise return false.
         *
         * @param {unknown} thing - The thing to check.
         *
         * @returns {boolean}
         */
        function isSpecCompliantForm(thing) {
          return !!(
            thing &&
            isFunction(thing.append) &&
            thing[Symbol.toStringTag] === 'FormData' &&
            thing[Symbol.iterator]
          );
        }

        const toJSONObject = obj => {
          const stack = new Array(10);

          const visit = (source, i) => {
            if (isObject(source)) {
              if (stack.indexOf(source) >= 0) {
                return;
              }

              if (!('toJSON' in source)) {
                stack[i] = source;
                const target = isArray(source) ? [] : {};

                forEach(source, (value, key) => {
                  const reducedValue = visit(value, i + 1);
                  !isUndefined(reducedValue) && (target[key] = reducedValue);
                });

                stack[i] = undefined;

                return target;
              }
            }

            return source;
          };

          return visit(obj, 0);
        };

        const isAsyncFn = kindOfTest('AsyncFunction');

        const isThenable = thing =>
          thing &&
          (isObject(thing) || isFunction(thing)) &&
          isFunction(thing.then) &&
          isFunction(thing.catch);

        // original code
        // https://github.com/DigitalBrainJS/AxiosPromise/blob/16deab13710ec09779922131f3fa5954320f83ab/lib/utils.js#L11-L34

        const _setImmediate = ((
          setImmediateSupported,
          postMessageSupported
        ) => {
          if (setImmediateSupported) {
            return setImmediate;
          }

          return postMessageSupported
            ? ((token, callbacks) => {
                _global.addEventListener(
                  'message',
                  ({ source, data }) => {
                    if (source === _global && data === token) {
                      callbacks.length && callbacks.shift()();
                    }
                  },
                  false
                );

                return cb => {
                  callbacks.push(cb);
                  _global.postMessage(token, '*');
                };
              })(`axios@${Math.random()}`, [])
            : cb => setTimeout(cb);
        })(typeof setImmediate === 'function', isFunction(_global.postMessage));

        const asap =
          typeof queueMicrotask !== 'undefined'
            ? queueMicrotask.bind(_global)
            : (typeof process !== 'undefined' && process.nextTick) ||
              _setImmediate;

        // *********************

        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = {
          isArray,
          isArrayBuffer,
          isBuffer,
          isFormData,
          isArrayBufferView,
          isString,
          isNumber,
          isBoolean,
          isObject,
          isPlainObject,
          isReadableStream,
          isRequest,
          isResponse,
          isHeaders,
          isUndefined,
          isDate,
          isFile,
          isBlob,
          isRegExp,
          isFunction,
          isStream,
          isURLSearchParams,
          isTypedArray,
          isFileList,
          forEach,
          merge,
          extend,
          trim,
          stripBOM,
          inherits,
          toFlatObject,
          kindOf,
          kindOfTest,
          endsWith,
          toArray,
          forEachEntry,
          matchAll,
          isHTMLForm,
          hasOwnProperty,
          hasOwnProp: hasOwnProperty, // an alias to avoid ESLint no-prototype-builtins detection
          reduceDescriptors,
          freezeMethods,
          toObjectSet,
          toCamelCase,
          noop,
          toFiniteNumber,
          findKey,
          global: _global,
          isContextDefined,
          isSpecCompliantForm,
          toJSONObject,
          isAsyncFn,
          isThenable,
          setImmediate: _setImmediate,
          asap
        };

        /***/
      },

    /***/ '../../node_modules/marked/lib/marked.esm.js':
      /*!***************************************************!*\
  !*** ../../node_modules/marked/lib/marked.esm.js ***!
  \***************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ Hooks: () => /* binding */ _Hooks,
          /* harmony export */ Lexer: () => /* binding */ _Lexer,
          /* harmony export */ Marked: () => /* binding */ Marked,
          /* harmony export */ Parser: () => /* binding */ _Parser,
          /* harmony export */ Renderer: () => /* binding */ _Renderer,
          /* harmony export */ TextRenderer: () => /* binding */ _TextRenderer,
          /* harmony export */ Tokenizer: () => /* binding */ _Tokenizer,
          /* harmony export */ defaults: () => /* binding */ _defaults,
          /* harmony export */ getDefaults: () => /* binding */ _getDefaults,
          /* harmony export */ lexer: () => /* binding */ lexer,
          /* harmony export */ marked: () => /* binding */ marked,
          /* harmony export */ options: () => /* binding */ options,
          /* harmony export */ parse: () => /* binding */ parse,
          /* harmony export */ parseInline: () => /* binding */ parseInline,
          /* harmony export */ parser: () => /* binding */ parser,
          /* harmony export */ setOptions: () => /* binding */ setOptions,
          /* harmony export */ use: () => /* binding */ use,
          /* harmony export */ walkTokens: () => /* binding */ walkTokens
          /* harmony export */
        });
        /**
         * marked v15.0.7 - a markdown parser
         * Copyright (c) 2011-2025, Christopher Jeffrey. (MIT Licensed)
         * https://github.com/markedjs/marked
         */

        /**
         * DO NOT EDIT THIS FILE
         * The code in this file is generated from files in ./src/
         */

        /**
         * Gets the original marked default options.
         */
        function _getDefaults() {
          return {
            async: false,
            breaks: false,
            extensions: null,
            gfm: true,
            hooks: null,
            pedantic: false,
            renderer: null,
            silent: false,
            tokenizer: null,
            walkTokens: null
          };
        }
        let _defaults = _getDefaults();
        function changeDefaults(newDefaults) {
          _defaults = newDefaults;
        }

        const noopTest = { exec: () => null };
        function edit(regex, opt = '') {
          let source = typeof regex === 'string' ? regex : regex.source;
          const obj = {
            replace: (name, val) => {
              let valSource = typeof val === 'string' ? val : val.source;
              valSource = valSource.replace(other.caret, '$1');
              source = source.replace(name, valSource);
              return obj;
            },
            getRegex: () => {
              return new RegExp(source, opt);
            }
          };
          return obj;
        }
        const other = {
          codeRemoveIndent: /^(?: {1,4}| {0,3}\t)/gm,
          outputLinkReplace: /\\([\[\]])/g,
          indentCodeCompensation: /^(\s+)(?:```)/,
          beginningSpace: /^\s+/,
          endingHash: /#$/,
          startingSpaceChar: /^ /,
          endingSpaceChar: / $/,
          nonSpaceChar: /[^ ]/,
          newLineCharGlobal: /\n/g,
          tabCharGlobal: /\t/g,
          multipleSpaceGlobal: /\s+/g,
          blankLine: /^[ \t]*$/,
          doubleBlankLine: /\n[ \t]*\n[ \t]*$/,
          blockquoteStart: /^ {0,3}>/,
          blockquoteSetextReplace: /\n {0,3}((?:=+|-+) *)(?=\n|$)/g,
          blockquoteSetextReplace2: /^ {0,3}>[ \t]?/gm,
          listReplaceTabs: /^\t+/,
          listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g,
          listIsTask: /^\[[ xX]\] /,
          listReplaceTask: /^\[[ xX]\] +/,
          anyLine: /\n.*\n/,
          hrefBrackets: /^<(.*)>$/,
          tableDelimiter: /[:|]/,
          tableAlignChars: /^\||\| *$/g,
          tableRowBlankLine: /\n[ \t]*$/,
          tableAlignRight: /^ *-+: *$/,
          tableAlignCenter: /^ *:-+: *$/,
          tableAlignLeft: /^ *:-+ *$/,
          startATag: /^<a /i,
          endATag: /^<\/a>/i,
          startPreScriptTag: /^<(pre|code|kbd|script)(\s|>)/i,
          endPreScriptTag: /^<\/(pre|code|kbd|script)(\s|>)/i,
          startAngleBracket: /^</,
          endAngleBracket: />$/,
          pedanticHrefTitle: /^([^'"]*[^\s])\s+(['"])(.*)\2/,
          unicodeAlphaNumeric: /[\p{L}\p{N}]/u,
          escapeTest: /[&<>"']/,
          escapeReplace: /[&<>"']/g,
          escapeTestNoEncode:
            /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,
          escapeReplaceNoEncode:
            /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g,
          unescapeTest: /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/gi,
          caret: /(^|[^\[])\^/g,
          percentDecode: /%25/g,
          findPipe: /\|/g,
          splitPipe: / \|/,
          slashPipe: /\\\|/g,
          carriageReturn: /\r\n|\r/g,
          spaceLine: /^ +$/gm,
          notSpaceStart: /^\S*/,
          endingNewline: /\n$/,
          listItemRegex: bull =>
            new RegExp(`^( {0,3}${bull})((?:[\t ][^\\n]*)?(?:\\n|$))`),
          nextBulletRegex: indent =>
            new RegExp(
              `^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ \t][^\\n]*)?(?:\\n|$))`
            ),
          hrRegex: indent =>
            new RegExp(
              `^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`
            ),
          fencesBeginRegex: indent =>
            new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\`\`\`|~~~)`),
          headingBeginRegex: indent =>
            new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`),
          htmlBeginRegex: indent =>
            new RegExp(`^ {0,${Math.min(3, indent - 1)}}<(?:[a-z].*>|!--)`, 'i')
        };
        /**
         * Block-Level Grammar
         */
        const newline = /^(?:[ \t]*(?:\n|$))+/;
        const blockCode =
          /^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/;
        const fences =
          /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/;
        const hr =
          /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/;
        const heading = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/;
        const bullet = /(?:[*+-]|\d{1,9}[.)])/;
        const lheadingCore =
          /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/;
        const lheading = edit(lheadingCore)
          .replace(/bull/g, bullet) // lists can interrupt
          .replace(/blockCode/g, /(?: {4}| {0,3}\t)/) // indented code blocks can interrupt
          .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/) // fenced code blocks can interrupt
          .replace(/blockquote/g, / {0,3}>/) // blockquote can interrupt
          .replace(/heading/g, / {0,3}#{1,6}/) // ATX heading can interrupt
          .replace(/html/g, / {0,3}<[^\n>]+>\n/) // block html can interrupt
          .replace(/\|table/g, '') // table not in commonmark
          .getRegex();
        const lheadingGfm = edit(lheadingCore)
          .replace(/bull/g, bullet) // lists can interrupt
          .replace(/blockCode/g, /(?: {4}| {0,3}\t)/) // indented code blocks can interrupt
          .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/) // fenced code blocks can interrupt
          .replace(/blockquote/g, / {0,3}>/) // blockquote can interrupt
          .replace(/heading/g, / {0,3}#{1,6}/) // ATX heading can interrupt
          .replace(/html/g, / {0,3}<[^\n>]+>\n/) // block html can interrupt
          .replace(/table/g, / {0,3}\|?(?:[:\- ]*\|)+[\:\- ]*\n/) // table can interrupt
          .getRegex();
        const _paragraph =
          /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/;
        const blockText = /^[^\n]+/;
        const _blockLabel = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
        const def = edit(
          /^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/
        )
          .replace('label', _blockLabel)
          .replace(
            'title',
            /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/
          )
          .getRegex();
        const list = edit(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/)
          .replace(/bull/g, bullet)
          .getRegex();
        const _tag =
          'address|article|aside|base|basefont|blockquote|body|caption' +
          '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption' +
          '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe' +
          '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option' +
          '|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title' +
          '|tr|track|ul';
        const _comment = /<!--(?:-?>|[\s\S]*?(?:-->|$))/;
        const html = edit(
          '^ {0,3}(?:' + // optional indentation
            '<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)' + // (1)
            '|comment[^\\n]*(\\n+|$)' + // (2)
            '|<\\?[\\s\\S]*?(?:\\?>\\n*|$)' + // (3)
            '|<![A-Z][\\s\\S]*?(?:>\\n*|$)' + // (4)
            '|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)' + // (5)
            '|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ \t]*)+\\n|$)' + // (6)
            '|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ \t]*)+\\n|$)' + // (7) open tag
            '|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ \t]*)+\\n|$)' + // (7) closing tag
            ')',
          'i'
        )
          .replace('comment', _comment)
          .replace('tag', _tag)
          .replace(
            'attribute',
            / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/
          )
          .getRegex();
        const paragraph = edit(_paragraph)
          .replace('hr', hr)
          .replace('heading', ' {0,3}#{1,6}(?:\\s|$)')
          .replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs
          .replace('|table', '')
          .replace('blockquote', ' {0,3}>')
          .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
          .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
          .replace(
            'html',
            '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)'
          )
          .replace('tag', _tag) // pars can be interrupted by type (6) html blocks
          .getRegex();
        const blockquote = edit(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/)
          .replace('paragraph', paragraph)
          .getRegex();
        /**
         * Normal Block Grammar
         */
        const blockNormal = {
          blockquote,
          code: blockCode,
          def,
          fences,
          heading,
          hr,
          html,
          lheading,
          list,
          newline,
          paragraph,
          table: noopTest,
          text: blockText
        };
        /**
         * GFM Block Grammar
         */
        const gfmTable = edit(
          '^ *([^\\n ].*)\\n' + // Header
            ' {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)' + // Align
            '(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)'
        ) // Cells
          .replace('hr', hr)
          .replace('heading', ' {0,3}#{1,6}(?:\\s|$)')
          .replace('blockquote', ' {0,3}>')
          .replace('code', '(?: {4}| {0,3}\t)[^\\n]')
          .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
          .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
          .replace(
            'html',
            '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)'
          )
          .replace('tag', _tag) // tables can be interrupted by type (6) html blocks
          .getRegex();
        const blockGfm = {
          ...blockNormal,
          lheading: lheadingGfm,
          table: gfmTable,
          paragraph: edit(_paragraph)
            .replace('hr', hr)
            .replace('heading', ' {0,3}#{1,6}(?:\\s|$)')
            .replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs
            .replace('table', gfmTable) // interrupt paragraphs with table
            .replace('blockquote', ' {0,3}>')
            .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
            .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
            .replace(
              'html',
              '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)'
            )
            .replace('tag', _tag) // pars can be interrupted by type (6) html blocks
            .getRegex()
        };
        /**
         * Pedantic grammar (original John Gruber's loose markdown specification)
         */
        const blockPedantic = {
          ...blockNormal,
          html: edit(
            '^ *(?:comment *(?:\\n|\\s*$)' +
              '|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)' + // closed tag
              '|<tag(?:"[^"]*"|\'[^\']*\'|\\s[^\'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))'
          )
            .replace('comment', _comment)
            .replace(
              /tag/g,
              '(?!(?:' +
                'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub' +
                '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)' +
                '\\b)\\w+(?!:|[^\\w\\s@]*@)\\b'
            )
            .getRegex(),
          def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
          heading: /^(#{1,6})(.*)(?:\n+|$)/,
          fences: noopTest, // fences not supported
          lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
          paragraph: edit(_paragraph)
            .replace('hr', hr)
            .replace('heading', ' *#{1,6} *[^\n]')
            .replace('lheading', lheading)
            .replace('|table', '')
            .replace('blockquote', ' {0,3}>')
            .replace('|fences', '')
            .replace('|list', '')
            .replace('|html', '')
            .replace('|tag', '')
            .getRegex()
        };
        /**
         * Inline-Level Grammar
         */
        const escape$1 = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/;
        const inlineCode = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/;
        const br = /^( {2,}|\\)\n(?!\s*$)/;
        const inlineText =
          /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/;
        // list of unicode punctuation marks, plus any missing characters from CommonMark spec
        const _punctuation = /[\p{P}\p{S}]/u;
        const _punctuationOrSpace = /[\s\p{P}\p{S}]/u;
        const _notPunctuationOrSpace = /[^\s\p{P}\p{S}]/u;
        const punctuation = edit(/^((?![*_])punctSpace)/, 'u')
          .replace(/punctSpace/g, _punctuationOrSpace)
          .getRegex();
        // GFM allows ~ inside strong and em for strikethrough
        const _punctuationGfmStrongEm = /(?!~)[\p{P}\p{S}]/u;
        const _punctuationOrSpaceGfmStrongEm = /(?!~)[\s\p{P}\p{S}]/u;
        const _notPunctuationOrSpaceGfmStrongEm = /(?:[^\s\p{P}\p{S}]|~)/u;
        // sequences em should skip over [title](link), `code`, <html>
        const blockSkip =
          /\[[^[\]]*?\]\((?:\\.|[^\\\(\)]|\((?:\\.|[^\\\(\)])*\))*\)|`[^`]*?`|<[^<>]*?>/g;
        const emStrongLDelimCore =
          /^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/;
        const emStrongLDelim = edit(emStrongLDelimCore, 'u')
          .replace(/punct/g, _punctuation)
          .getRegex();
        const emStrongLDelimGfm = edit(emStrongLDelimCore, 'u')
          .replace(/punct/g, _punctuationGfmStrongEm)
          .getRegex();
        const emStrongRDelimAstCore =
          '^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)' + // Skip orphan inside strong
          '|[^*]+(?=[^*])' + // Consume to delim
          '|(?!\\*)punct(\\*+)(?=[\\s]|$)' + // (1) #*** can only be a Right Delimiter
          '|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)' + // (2) a***#, a*** can only be a Right Delimiter
          '|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)' + // (3) #***a, ***a can only be Left Delimiter
          '|[\\s](\\*+)(?!\\*)(?=punct)' + // (4) ***# can only be Left Delimiter
          '|(?!\\*)punct(\\*+)(?!\\*)(?=punct)' + // (5) #***# can be either Left or Right Delimiter
          '|notPunctSpace(\\*+)(?=notPunctSpace)'; // (6) a***a can be either Left or Right Delimiter
        const emStrongRDelimAst = edit(emStrongRDelimAstCore, 'gu')
          .replace(/notPunctSpace/g, _notPunctuationOrSpace)
          .replace(/punctSpace/g, _punctuationOrSpace)
          .replace(/punct/g, _punctuation)
          .getRegex();
        const emStrongRDelimAstGfm = edit(emStrongRDelimAstCore, 'gu')
          .replace(/notPunctSpace/g, _notPunctuationOrSpaceGfmStrongEm)
          .replace(/punctSpace/g, _punctuationOrSpaceGfmStrongEm)
          .replace(/punct/g, _punctuationGfmStrongEm)
          .getRegex();
        // (6) Not allowed for _
        const emStrongRDelimUnd = edit(
          '^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)' + // Skip orphan inside strong
            '|[^_]+(?=[^_])' + // Consume to delim
            '|(?!_)punct(_+)(?=[\\s]|$)' + // (1) #___ can only be a Right Delimiter
            '|notPunctSpace(_+)(?!_)(?=punctSpace|$)' + // (2) a___#, a___ can only be a Right Delimiter
            '|(?!_)punctSpace(_+)(?=notPunctSpace)' + // (3) #___a, ___a can only be Left Delimiter
            '|[\\s](_+)(?!_)(?=punct)' + // (4) ___# can only be Left Delimiter
            '|(?!_)punct(_+)(?!_)(?=punct)',
          'gu'
        ) // (5) #___# can be either Left or Right Delimiter
          .replace(/notPunctSpace/g, _notPunctuationOrSpace)
          .replace(/punctSpace/g, _punctuationOrSpace)
          .replace(/punct/g, _punctuation)
          .getRegex();
        const anyPunctuation = edit(/\\(punct)/, 'gu')
          .replace(/punct/g, _punctuation)
          .getRegex();
        const autolink = edit(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/)
          .replace('scheme', /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/)
          .replace(
            'email',
            /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/
          )
          .getRegex();
        const _inlineComment = edit(_comment)
          .replace('(?:-->|$)', '-->')
          .getRegex();
        const tag = edit(
          '^comment' +
            '|^</[a-zA-Z][\\w:-]*\\s*>' + // self-closing tag
            '|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>' + // open tag
            '|^<\\?[\\s\\S]*?\\?>' + // processing instruction, e.g. <?php ?>
            '|^<![a-zA-Z]+\\s[\\s\\S]*?>' + // declaration, e.g. <!DOCTYPE html>
            '|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>'
        ) // CDATA section
          .replace('comment', _inlineComment)
          .replace(
            'attribute',
            /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/
          )
          .getRegex();
        const _inlineLabel =
          /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
        const link = edit(/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/)
          .replace('label', _inlineLabel)
          .replace('href', /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/)
          .replace(
            'title',
            /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/
          )
          .getRegex();
        const reflink = edit(/^!?\[(label)\]\[(ref)\]/)
          .replace('label', _inlineLabel)
          .replace('ref', _blockLabel)
          .getRegex();
        const nolink = edit(/^!?\[(ref)\](?:\[\])?/)
          .replace('ref', _blockLabel)
          .getRegex();
        const reflinkSearch = edit('reflink|nolink(?!\\()', 'g')
          .replace('reflink', reflink)
          .replace('nolink', nolink)
          .getRegex();
        /**
         * Normal Inline Grammar
         */
        const inlineNormal = {
          _backpedal: noopTest, // only used for GFM url
          anyPunctuation,
          autolink,
          blockSkip,
          br,
          code: inlineCode,
          del: noopTest,
          emStrongLDelim,
          emStrongRDelimAst,
          emStrongRDelimUnd,
          escape: escape$1,
          link,
          nolink,
          punctuation,
          reflink,
          reflinkSearch,
          tag,
          text: inlineText,
          url: noopTest
        };
        /**
         * Pedantic Inline Grammar
         */
        const inlinePedantic = {
          ...inlineNormal,
          link: edit(/^!?\[(label)\]\((.*?)\)/)
            .replace('label', _inlineLabel)
            .getRegex(),
          reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/)
            .replace('label', _inlineLabel)
            .getRegex()
        };
        /**
         * GFM Inline Grammar
         */
        const inlineGfm = {
          ...inlineNormal,
          emStrongRDelimAst: emStrongRDelimAstGfm,
          emStrongLDelim: emStrongLDelimGfm,
          url: edit(
            /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
            'i'
          )
            .replace(
              'email',
              /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/
            )
            .getRegex(),
          _backpedal:
            /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
          del: /^(~~?)(?=[^\s~])((?:\\.|[^\\])*?(?:\\.|[^\s~\\]))\1(?=[^~]|$)/,
          text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
        };
        /**
         * GFM + Line Breaks Inline Grammar
         */
        const inlineBreaks = {
          ...inlineGfm,
          br: edit(br).replace('{2,}', '*').getRegex(),
          text: edit(inlineGfm.text)
            .replace('\\b_', '\\b_| {2,}\\n')
            .replace(/\{2,\}/g, '*')
            .getRegex()
        };
        /**
         * exports
         */
        const block = {
          normal: blockNormal,
          gfm: blockGfm,
          pedantic: blockPedantic
        };
        const inline = {
          normal: inlineNormal,
          gfm: inlineGfm,
          breaks: inlineBreaks,
          pedantic: inlinePedantic
        };

        /**
         * Helpers
         */
        const escapeReplacements = {
          '&': '&amp;',
          '<': '&lt;',
          '>': '&gt;',
          '"': '&quot;',
          "'": '&#39;'
        };
        const getEscapeReplacement = ch => escapeReplacements[ch];
        function escape(html, encode) {
          if (encode) {
            if (other.escapeTest.test(html)) {
              return html.replace(other.escapeReplace, getEscapeReplacement);
            }
          } else {
            if (other.escapeTestNoEncode.test(html)) {
              return html.replace(
                other.escapeReplaceNoEncode,
                getEscapeReplacement
              );
            }
          }
          return html;
        }
        function cleanUrl(href) {
          try {
            href = encodeURI(href).replace(other.percentDecode, '%');
          } catch {
            return null;
          }
          return href;
        }
        function splitCells(tableRow, count) {
          // ensure that every cell-delimiting pipe has a space
          // before it to distinguish it from an escaped pipe
          const row = tableRow.replace(other.findPipe, (match, offset, str) => {
              let escaped = false;
              let curr = offset;
              while (--curr >= 0 && str[curr] === '\\') escaped = !escaped;
              if (escaped) {
                // odd number of slashes means | is escaped
                // so we leave it alone
                return '|';
              } else {
                // add space before unescaped |
                return ' |';
              }
            }),
            cells = row.split(other.splitPipe);
          let i = 0;
          // First/last cell in a row cannot be empty if it has no leading/trailing pipe
          if (!cells[0].trim()) {
            cells.shift();
          }
          if (cells.length > 0 && !cells.at(-1)?.trim()) {
            cells.pop();
          }
          if (count) {
            if (cells.length > count) {
              cells.splice(count);
            } else {
              while (cells.length < count) cells.push('');
            }
          }
          for (; i < cells.length; i++) {
            // leading or trailing whitespace is ignored per the gfm spec
            cells[i] = cells[i].trim().replace(other.slashPipe, '|');
          }
          return cells;
        }
        /**
         * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').
         * /c*$/ is vulnerable to REDOS.
         *
         * @param str
         * @param c
         * @param invert Remove suffix of non-c chars instead. Default falsey.
         */
        function rtrim(str, c, invert) {
          const l = str.length;
          if (l === 0) {
            return '';
          }
          // Length of suffix matching the invert condition.
          let suffLen = 0;
          // Step left until we fail to match the invert condition.
          while (suffLen < l) {
            const currChar = str.charAt(l - suffLen - 1);
            if (currChar === c && true) {
              suffLen++;
            } else {
              break;
            }
          }
          return str.slice(0, l - suffLen);
        }
        function findClosingBracket(str, b) {
          if (str.indexOf(b[1]) === -1) {
            return -1;
          }
          let level = 0;
          for (let i = 0; i < str.length; i++) {
            if (str[i] === '\\') {
              i++;
            } else if (str[i] === b[0]) {
              level++;
            } else if (str[i] === b[1]) {
              level--;
              if (level < 0) {
                return i;
              }
            }
          }
          return -1;
        }

        function outputLink(cap, link, raw, lexer, rules) {
          const href = link.href;
          const title = link.title || null;
          const text = cap[1].replace(rules.other.outputLinkReplace, '$1');
          if (cap[0].charAt(0) !== '!') {
            lexer.state.inLink = true;
            const token = {
              type: 'link',
              raw,
              href,
              title,
              text,
              tokens: lexer.inlineTokens(text)
            };
            lexer.state.inLink = false;
            return token;
          }
          return {
            type: 'image',
            raw,
            href,
            title,
            text
          };
        }
        function indentCodeCompensation(raw, text, rules) {
          const matchIndentToCode = raw.match(
            rules.other.indentCodeCompensation
          );
          if (matchIndentToCode === null) {
            return text;
          }
          const indentToCode = matchIndentToCode[1];
          return text
            .split('\n')
            .map(node => {
              const matchIndentInNode = node.match(rules.other.beginningSpace);
              if (matchIndentInNode === null) {
                return node;
              }
              const [indentInNode] = matchIndentInNode;
              if (indentInNode.length >= indentToCode.length) {
                return node.slice(indentToCode.length);
              }
              return node;
            })
            .join('\n');
        }
        /**
         * Tokenizer
         */
        class _Tokenizer {
          options;
          rules; // set by the lexer
          lexer; // set by the lexer
          constructor(options) {
            this.options = options || _defaults;
          }
          space(src) {
            const cap = this.rules.block.newline.exec(src);
            if (cap && cap[0].length > 0) {
              return {
                type: 'space',
                raw: cap[0]
              };
            }
          }
          code(src) {
            const cap = this.rules.block.code.exec(src);
            if (cap) {
              const text = cap[0].replace(
                this.rules.other.codeRemoveIndent,
                ''
              );
              return {
                type: 'code',
                raw: cap[0],
                codeBlockStyle: 'indented',
                text: !this.options.pedantic ? rtrim(text, '\n') : text
              };
            }
          }
          fences(src) {
            const cap = this.rules.block.fences.exec(src);
            if (cap) {
              const raw = cap[0];
              const text = indentCodeCompensation(
                raw,
                cap[3] || '',
                this.rules
              );
              return {
                type: 'code',
                raw,
                lang: cap[2]
                  ? cap[2]
                      .trim()
                      .replace(this.rules.inline.anyPunctuation, '$1')
                  : cap[2],
                text
              };
            }
          }
          heading(src) {
            const cap = this.rules.block.heading.exec(src);
            if (cap) {
              let text = cap[2].trim();
              // remove trailing #s
              if (this.rules.other.endingHash.test(text)) {
                const trimmed = rtrim(text, '#');
                if (this.options.pedantic) {
                  text = trimmed.trim();
                } else if (
                  !trimmed ||
                  this.rules.other.endingSpaceChar.test(trimmed)
                ) {
                  // CommonMark requires space before trailing #s
                  text = trimmed.trim();
                }
              }
              return {
                type: 'heading',
                raw: cap[0],
                depth: cap[1].length,
                text,
                tokens: this.lexer.inline(text)
              };
            }
          }
          hr(src) {
            const cap = this.rules.block.hr.exec(src);
            if (cap) {
              return {
                type: 'hr',
                raw: rtrim(cap[0], '\n')
              };
            }
          }
          blockquote(src) {
            const cap = this.rules.block.blockquote.exec(src);
            if (cap) {
              let lines = rtrim(cap[0], '\n').split('\n');
              let raw = '';
              let text = '';
              const tokens = [];
              while (lines.length > 0) {
                let inBlockquote = false;
                const currentLines = [];
                let i;
                for (i = 0; i < lines.length; i++) {
                  // get lines up to a continuation
                  if (this.rules.other.blockquoteStart.test(lines[i])) {
                    currentLines.push(lines[i]);
                    inBlockquote = true;
                  } else if (!inBlockquote) {
                    currentLines.push(lines[i]);
                  } else {
                    break;
                  }
                }
                lines = lines.slice(i);
                const currentRaw = currentLines.join('\n');
                const currentText = currentRaw
                  // precede setext continuation with 4 spaces so it isn't a setext
                  .replace(this.rules.other.blockquoteSetextReplace, '\n    $1')
                  .replace(this.rules.other.blockquoteSetextReplace2, '');
                raw = raw ? `${raw}\n${currentRaw}` : currentRaw;
                text = text ? `${text}\n${currentText}` : currentText;
                // parse blockquote lines as top level tokens
                // merge paragraphs if this is a continuation
                const top = this.lexer.state.top;
                this.lexer.state.top = true;
                this.lexer.blockTokens(currentText, tokens, true);
                this.lexer.state.top = top;
                // if there is no continuation then we are done
                if (lines.length === 0) {
                  break;
                }
                const lastToken = tokens.at(-1);
                if (lastToken?.type === 'code') {
                  // blockquote continuation cannot be preceded by a code block
                  break;
                } else if (lastToken?.type === 'blockquote') {
                  // include continuation in nested blockquote
                  const oldToken = lastToken;
                  const newText = oldToken.raw + '\n' + lines.join('\n');
                  const newToken = this.blockquote(newText);
                  tokens[tokens.length - 1] = newToken;
                  raw =
                    raw.substring(0, raw.length - oldToken.raw.length) +
                    newToken.raw;
                  text =
                    text.substring(0, text.length - oldToken.text.length) +
                    newToken.text;
                  break;
                } else if (lastToken?.type === 'list') {
                  // include continuation in nested list
                  const oldToken = lastToken;
                  const newText = oldToken.raw + '\n' + lines.join('\n');
                  const newToken = this.list(newText);
                  tokens[tokens.length - 1] = newToken;
                  raw =
                    raw.substring(0, raw.length - lastToken.raw.length) +
                    newToken.raw;
                  text =
                    text.substring(0, text.length - oldToken.raw.length) +
                    newToken.raw;
                  lines = newText
                    .substring(tokens.at(-1).raw.length)
                    .split('\n');
                  continue;
                }
              }
              return {
                type: 'blockquote',
                raw,
                tokens,
                text
              };
            }
          }
          list(src) {
            let cap = this.rules.block.list.exec(src);
            if (cap) {
              let bull = cap[1].trim();
              const isordered = bull.length > 1;
              const list = {
                type: 'list',
                raw: '',
                ordered: isordered,
                start: isordered ? +bull.slice(0, -1) : '',
                loose: false,
                items: []
              };
              bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
              if (this.options.pedantic) {
                bull = isordered ? bull : '[*+-]';
              }
              // Get next list item
              const itemRegex = this.rules.other.listItemRegex(bull);
              let endsWithBlankLine = false;
              // Check if current bullet point can start a new List Item
              while (src) {
                let endEarly = false;
                let raw = '';
                let itemContents = '';
                if (!(cap = itemRegex.exec(src))) {
                  break;
                }
                if (this.rules.block.hr.test(src)) {
                  // End list if bullet was actually HR (possibly move into itemRegex?)
                  break;
                }
                raw = cap[0];
                src = src.substring(raw.length);
                let line = cap[2]
                  .split('\n', 1)[0]
                  .replace(this.rules.other.listReplaceTabs, t =>
                    ' '.repeat(3 * t.length)
                  );
                let nextLine = src.split('\n', 1)[0];
                let blankLine = !line.trim();
                let indent = 0;
                if (this.options.pedantic) {
                  indent = 2;
                  itemContents = line.trimStart();
                } else if (blankLine) {
                  indent = cap[1].length + 1;
                } else {
                  indent = cap[2].search(this.rules.other.nonSpaceChar); // Find first non-space char
                  indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent
                  itemContents = line.slice(indent);
                  indent += cap[1].length;
                }
                if (blankLine && this.rules.other.blankLine.test(nextLine)) {
                  // Items begin with at most one blank line
                  raw += nextLine + '\n';
                  src = src.substring(nextLine.length + 1);
                  endEarly = true;
                }
                if (!endEarly) {
                  const nextBulletRegex =
                    this.rules.other.nextBulletRegex(indent);
                  const hrRegex = this.rules.other.hrRegex(indent);
                  const fencesBeginRegex =
                    this.rules.other.fencesBeginRegex(indent);
                  const headingBeginRegex =
                    this.rules.other.headingBeginRegex(indent);
                  const htmlBeginRegex =
                    this.rules.other.htmlBeginRegex(indent);
                  // Check if following lines should be included in List Item
                  while (src) {
                    const rawLine = src.split('\n', 1)[0];
                    let nextLineWithoutTabs;
                    nextLine = rawLine;
                    // Re-align to follow commonmark nesting rules
                    if (this.options.pedantic) {
                      nextLine = nextLine.replace(
                        this.rules.other.listReplaceNesting,
                        '  '
                      );
                      nextLineWithoutTabs = nextLine;
                    } else {
                      nextLineWithoutTabs = nextLine.replace(
                        this.rules.other.tabCharGlobal,
                        '    '
                      );
                    }
                    // End list item if found code fences
                    if (fencesBeginRegex.test(nextLine)) {
                      break;
                    }
                    // End list item if found start of new heading
                    if (headingBeginRegex.test(nextLine)) {
                      break;
                    }
                    // End list item if found start of html block
                    if (htmlBeginRegex.test(nextLine)) {
                      break;
                    }
                    // End list item if found start of new bullet
                    if (nextBulletRegex.test(nextLine)) {
                      break;
                    }
                    // Horizontal rule found
                    if (hrRegex.test(nextLine)) {
                      break;
                    }
                    if (
                      nextLineWithoutTabs.search(
                        this.rules.other.nonSpaceChar
                      ) >= indent ||
                      !nextLine.trim()
                    ) {
                      // Dedent if possible
                      itemContents += '\n' + nextLineWithoutTabs.slice(indent);
                    } else {
                      // not enough indentation
                      if (blankLine) {
                        break;
                      }
                      // paragraph continuation unless last line was a different block level element
                      if (
                        line
                          .replace(this.rules.other.tabCharGlobal, '    ')
                          .search(this.rules.other.nonSpaceChar) >= 4
                      ) {
                        // indented code block
                        break;
                      }
                      if (fencesBeginRegex.test(line)) {
                        break;
                      }
                      if (headingBeginRegex.test(line)) {
                        break;
                      }
                      if (hrRegex.test(line)) {
                        break;
                      }
                      itemContents += '\n' + nextLine;
                    }
                    if (!blankLine && !nextLine.trim()) {
                      // Check if current line is blank
                      blankLine = true;
                    }
                    raw += rawLine + '\n';
                    src = src.substring(rawLine.length + 1);
                    line = nextLineWithoutTabs.slice(indent);
                  }
                }
                if (!list.loose) {
                  // If the previous item ended with a blank line, the list is loose
                  if (endsWithBlankLine) {
                    list.loose = true;
                  } else if (this.rules.other.doubleBlankLine.test(raw)) {
                    endsWithBlankLine = true;
                  }
                }
                let istask = null;
                let ischecked;
                // Check for task list items
                if (this.options.gfm) {
                  istask = this.rules.other.listIsTask.exec(itemContents);
                  if (istask) {
                    ischecked = istask[0] !== '[ ] ';
                    itemContents = itemContents.replace(
                      this.rules.other.listReplaceTask,
                      ''
                    );
                  }
                }
                list.items.push({
                  type: 'list_item',
                  raw,
                  task: !!istask,
                  checked: ischecked,
                  loose: false,
                  text: itemContents,
                  tokens: []
                });
                list.raw += raw;
              }
              // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic
              const lastItem = list.items.at(-1);
              if (lastItem) {
                lastItem.raw = lastItem.raw.trimEnd();
                lastItem.text = lastItem.text.trimEnd();
              } else {
                // not a list since there were no items
                return;
              }
              list.raw = list.raw.trimEnd();
              // Item child tokens handled here at end because we needed to have the final item to trim it first
              for (let i = 0; i < list.items.length; i++) {
                this.lexer.state.top = false;
                list.items[i].tokens = this.lexer.blockTokens(
                  list.items[i].text,
                  []
                );
                if (!list.loose) {
                  // Check if list should be loose
                  const spacers = list.items[i].tokens.filter(
                    t => t.type === 'space'
                  );
                  const hasMultipleLineBreaks =
                    spacers.length > 0 &&
                    spacers.some(t => this.rules.other.anyLine.test(t.raw));
                  list.loose = hasMultipleLineBreaks;
                }
              }
              // Set all items to loose if list is loose
              if (list.loose) {
                for (let i = 0; i < list.items.length; i++) {
                  list.items[i].loose = true;
                }
              }
              return list;
            }
          }
          html(src) {
            const cap = this.rules.block.html.exec(src);
            if (cap) {
              const token = {
                type: 'html',
                block: true,
                raw: cap[0],
                pre:
                  cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',
                text: cap[0]
              };
              return token;
            }
          }
          def(src) {
            const cap = this.rules.block.def.exec(src);
            if (cap) {
              const tag = cap[1]
                .toLowerCase()
                .replace(this.rules.other.multipleSpaceGlobal, ' ');
              const href = cap[2]
                ? cap[2]
                    .replace(this.rules.other.hrefBrackets, '$1')
                    .replace(this.rules.inline.anyPunctuation, '$1')
                : '';
              const title = cap[3]
                ? cap[3]
                    .substring(1, cap[3].length - 1)
                    .replace(this.rules.inline.anyPunctuation, '$1')
                : cap[3];
              return {
                type: 'def',
                tag,
                raw: cap[0],
                href,
                title
              };
            }
          }
          table(src) {
            const cap = this.rules.block.table.exec(src);
            if (!cap) {
              return;
            }
            if (!this.rules.other.tableDelimiter.test(cap[2])) {
              // delimiter row must have a pipe (|) or colon (:) otherwise it is a setext heading
              return;
            }
            const headers = splitCells(cap[1]);
            const aligns = cap[2]
              .replace(this.rules.other.tableAlignChars, '')
              .split('|');
            const rows = cap[3]?.trim()
              ? cap[3]
                  .replace(this.rules.other.tableRowBlankLine, '')
                  .split('\n')
              : [];
            const item = {
              type: 'table',
              raw: cap[0],
              header: [],
              align: [],
              rows: []
            };
            if (headers.length !== aligns.length) {
              // header and align columns must be equal, rows can be different.
              return;
            }
            for (const align of aligns) {
              if (this.rules.other.tableAlignRight.test(align)) {
                item.align.push('right');
              } else if (this.rules.other.tableAlignCenter.test(align)) {
                item.align.push('center');
              } else if (this.rules.other.tableAlignLeft.test(align)) {
                item.align.push('left');
              } else {
                item.align.push(null);
              }
            }
            for (let i = 0; i < headers.length; i++) {
              item.header.push({
                text: headers[i],
                tokens: this.lexer.inline(headers[i]),
                header: true,
                align: item.align[i]
              });
            }
            for (const row of rows) {
              item.rows.push(
                splitCells(row, item.header.length).map((cell, i) => {
                  return {
                    text: cell,
                    tokens: this.lexer.inline(cell),
                    header: false,
                    align: item.align[i]
                  };
                })
              );
            }
            return item;
          }
          lheading(src) {
            const cap = this.rules.block.lheading.exec(src);
            if (cap) {
              return {
                type: 'heading',
                raw: cap[0],
                depth: cap[2].charAt(0) === '=' ? 1 : 2,
                text: cap[1],
                tokens: this.lexer.inline(cap[1])
              };
            }
          }
          paragraph(src) {
            const cap = this.rules.block.paragraph.exec(src);
            if (cap) {
              const text =
                cap[1].charAt(cap[1].length - 1) === '\n'
                  ? cap[1].slice(0, -1)
                  : cap[1];
              return {
                type: 'paragraph',
                raw: cap[0],
                text,
                tokens: this.lexer.inline(text)
              };
            }
          }
          text(src) {
            const cap = this.rules.block.text.exec(src);
            if (cap) {
              return {
                type: 'text',
                raw: cap[0],
                text: cap[0],
                tokens: this.lexer.inline(cap[0])
              };
            }
          }
          escape(src) {
            const cap = this.rules.inline.escape.exec(src);
            if (cap) {
              return {
                type: 'escape',
                raw: cap[0],
                text: cap[1]
              };
            }
          }
          tag(src) {
            const cap = this.rules.inline.tag.exec(src);
            if (cap) {
              if (
                !this.lexer.state.inLink &&
                this.rules.other.startATag.test(cap[0])
              ) {
                this.lexer.state.inLink = true;
              } else if (
                this.lexer.state.inLink &&
                this.rules.other.endATag.test(cap[0])
              ) {
                this.lexer.state.inLink = false;
              }
              if (
                !this.lexer.state.inRawBlock &&
                this.rules.other.startPreScriptTag.test(cap[0])
              ) {
                this.lexer.state.inRawBlock = true;
              } else if (
                this.lexer.state.inRawBlock &&
                this.rules.other.endPreScriptTag.test(cap[0])
              ) {
                this.lexer.state.inRawBlock = false;
              }
              return {
                type: 'html',
                raw: cap[0],
                inLink: this.lexer.state.inLink,
                inRawBlock: this.lexer.state.inRawBlock,
                block: false,
                text: cap[0]
              };
            }
          }
          link(src) {
            const cap = this.rules.inline.link.exec(src);
            if (cap) {
              const trimmedUrl = cap[2].trim();
              if (
                !this.options.pedantic &&
                this.rules.other.startAngleBracket.test(trimmedUrl)
              ) {
                // commonmark requires matching angle brackets
                if (!this.rules.other.endAngleBracket.test(trimmedUrl)) {
                  return;
                }
                // ending angle bracket cannot be escaped
                const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\');
                if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
                  return;
                }
              } else {
                // find closing parenthesis
                const lastParenIndex = findClosingBracket(cap[2], '()');
                if (lastParenIndex > -1) {
                  const start = cap[0].indexOf('!') === 0 ? 5 : 4;
                  const linkLen = start + cap[1].length + lastParenIndex;
                  cap[2] = cap[2].substring(0, lastParenIndex);
                  cap[0] = cap[0].substring(0, linkLen).trim();
                  cap[3] = '';
                }
              }
              let href = cap[2];
              let title = '';
              if (this.options.pedantic) {
                // split pedantic href and title
                const link = this.rules.other.pedanticHrefTitle.exec(href);
                if (link) {
                  href = link[1];
                  title = link[3];
                }
              } else {
                title = cap[3] ? cap[3].slice(1, -1) : '';
              }
              href = href.trim();
              if (this.rules.other.startAngleBracket.test(href)) {
                if (
                  this.options.pedantic &&
                  !this.rules.other.endAngleBracket.test(trimmedUrl)
                ) {
                  // pedantic allows starting angle bracket without ending angle bracket
                  href = href.slice(1);
                } else {
                  href = href.slice(1, -1);
                }
              }
              return outputLink(
                cap,
                {
                  href: href
                    ? href.replace(this.rules.inline.anyPunctuation, '$1')
                    : href,
                  title: title
                    ? title.replace(this.rules.inline.anyPunctuation, '$1')
                    : title
                },
                cap[0],
                this.lexer,
                this.rules
              );
            }
          }
          reflink(src, links) {
            let cap;
            if (
              (cap = this.rules.inline.reflink.exec(src)) ||
              (cap = this.rules.inline.nolink.exec(src))
            ) {
              const linkString = (cap[2] || cap[1]).replace(
                this.rules.other.multipleSpaceGlobal,
                ' '
              );
              const link = links[linkString.toLowerCase()];
              if (!link) {
                const text = cap[0].charAt(0);
                return {
                  type: 'text',
                  raw: text,
                  text
                };
              }
              return outputLink(cap, link, cap[0], this.lexer, this.rules);
            }
          }
          emStrong(src, maskedSrc, prevChar = '') {
            let match = this.rules.inline.emStrongLDelim.exec(src);
            if (!match) return;
            // _ can't be between two alphanumerics. \p{L}\p{N} includes non-english alphabet/numbers as well
            if (
              match[3] &&
              prevChar.match(this.rules.other.unicodeAlphaNumeric)
            )
              return;
            const nextChar = match[1] || match[2] || '';
            if (
              !nextChar ||
              !prevChar ||
              this.rules.inline.punctuation.exec(prevChar)
            ) {
              // unicode Regex counts emoji as 1 char; spread into array for proper count (used multiple times below)
              const lLength = [...match[0]].length - 1;
              let rDelim,
                rLength,
                delimTotal = lLength,
                midDelimTotal = 0;
              const endReg =
                match[0][0] === '*'
                  ? this.rules.inline.emStrongRDelimAst
                  : this.rules.inline.emStrongRDelimUnd;
              endReg.lastIndex = 0;
              // Clip maskedSrc to same section of string as src (move to lexer?)
              maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
              while ((match = endReg.exec(maskedSrc)) != null) {
                rDelim =
                  match[1] ||
                  match[2] ||
                  match[3] ||
                  match[4] ||
                  match[5] ||
                  match[6];
                if (!rDelim) continue; // skip single * in __abc*abc__
                rLength = [...rDelim].length;
                if (match[3] || match[4]) {
                  // found another Left Delim
                  delimTotal += rLength;
                  continue;
                } else if (match[5] || match[6]) {
                  // either Left or Right Delim
                  if (lLength % 3 && !((lLength + rLength) % 3)) {
                    midDelimTotal += rLength;
                    continue; // CommonMark Emphasis Rules 9-10
                  }
                }
                delimTotal -= rLength;
                if (delimTotal > 0) continue; // Haven't found enough closing delimiters
                // Remove extra characters. *a*** -> *a*
                rLength = Math.min(
                  rLength,
                  rLength + delimTotal + midDelimTotal
                );
                // char length can be >1 for unicode characters;
                const lastCharLength = [...match[0]][0].length;
                const raw = src.slice(
                  0,
                  lLength + match.index + lastCharLength + rLength
                );
                // Create `em` if smallest delimiter has odd char count. *a***
                if (Math.min(lLength, rLength) % 2) {
                  const text = raw.slice(1, -1);
                  return {
                    type: 'em',
                    raw,
                    text,
                    tokens: this.lexer.inlineTokens(text)
                  };
                }
                // Create 'strong' if smallest delimiter has even char count. **a***
                const text = raw.slice(2, -2);
                return {
                  type: 'strong',
                  raw,
                  text,
                  tokens: this.lexer.inlineTokens(text)
                };
              }
            }
          }
          codespan(src) {
            const cap = this.rules.inline.code.exec(src);
            if (cap) {
              let text = cap[2].replace(
                this.rules.other.newLineCharGlobal,
                ' '
              );
              const hasNonSpaceChars = this.rules.other.nonSpaceChar.test(text);
              const hasSpaceCharsOnBothEnds =
                this.rules.other.startingSpaceChar.test(text) &&
                this.rules.other.endingSpaceChar.test(text);
              if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
                text = text.substring(1, text.length - 1);
              }
              return {
                type: 'codespan',
                raw: cap[0],
                text
              };
            }
          }
          br(src) {
            const cap = this.rules.inline.br.exec(src);
            if (cap) {
              return {
                type: 'br',
                raw: cap[0]
              };
            }
          }
          del(src) {
            const cap = this.rules.inline.del.exec(src);
            if (cap) {
              return {
                type: 'del',
                raw: cap[0],
                text: cap[2],
                tokens: this.lexer.inlineTokens(cap[2])
              };
            }
          }
          autolink(src) {
            const cap = this.rules.inline.autolink.exec(src);
            if (cap) {
              let text, href;
              if (cap[2] === '@') {
                text = cap[1];
                href = 'mailto:' + text;
              } else {
                text = cap[1];
                href = text;
              }
              return {
                type: 'link',
                raw: cap[0],
                text,
                href,
                tokens: [
                  {
                    type: 'text',
                    raw: text,
                    text
                  }
                ]
              };
            }
          }
          url(src) {
            let cap;
            if ((cap = this.rules.inline.url.exec(src))) {
              let text, href;
              if (cap[2] === '@') {
                text = cap[0];
                href = 'mailto:' + text;
              } else {
                // do extended autolink path validation
                let prevCapZero;
                do {
                  prevCapZero = cap[0];
                  cap[0] = this.rules.inline._backpedal.exec(cap[0])?.[0] ?? '';
                } while (prevCapZero !== cap[0]);
                text = cap[0];
                if (cap[1] === 'www.') {
                  href = 'http://' + cap[0];
                } else {
                  href = cap[0];
                }
              }
              return {
                type: 'link',
                raw: cap[0],
                text,
                href,
                tokens: [
                  {
                    type: 'text',
                    raw: text,
                    text
                  }
                ]
              };
            }
          }
          inlineText(src) {
            const cap = this.rules.inline.text.exec(src);
            if (cap) {
              const escaped = this.lexer.state.inRawBlock;
              return {
                type: 'text',
                raw: cap[0],
                text: cap[0],
                escaped
              };
            }
          }
        }

        /**
         * Block Lexer
         */
        class _Lexer {
          tokens;
          options;
          state;
          tokenizer;
          inlineQueue;
          constructor(options) {
            // TokenList cannot be created in one go
            this.tokens = [];
            this.tokens.links = Object.create(null);
            this.options = options || _defaults;
            this.options.tokenizer = this.options.tokenizer || new _Tokenizer();
            this.tokenizer = this.options.tokenizer;
            this.tokenizer.options = this.options;
            this.tokenizer.lexer = this;
            this.inlineQueue = [];
            this.state = {
              inLink: false,
              inRawBlock: false,
              top: true
            };
            const rules = {
              other,
              block: block.normal,
              inline: inline.normal
            };
            if (this.options.pedantic) {
              rules.block = block.pedantic;
              rules.inline = inline.pedantic;
            } else if (this.options.gfm) {
              rules.block = block.gfm;
              if (this.options.breaks) {
                rules.inline = inline.breaks;
              } else {
                rules.inline = inline.gfm;
              }
            }
            this.tokenizer.rules = rules;
          }
          /**
           * Expose Rules
           */
          static get rules() {
            return {
              block,
              inline
            };
          }
          /**
           * Static Lex Method
           */
          static lex(src, options) {
            const lexer = new _Lexer(options);
            return lexer.lex(src);
          }
          /**
           * Static Lex Inline Method
           */
          static lexInline(src, options) {
            const lexer = new _Lexer(options);
            return lexer.inlineTokens(src);
          }
          /**
           * Preprocessing
           */
          lex(src) {
            src = src.replace(other.carriageReturn, '\n');
            this.blockTokens(src, this.tokens);
            for (let i = 0; i < this.inlineQueue.length; i++) {
              const next = this.inlineQueue[i];
              this.inlineTokens(next.src, next.tokens);
            }
            this.inlineQueue = [];
            return this.tokens;
          }
          blockTokens(src, tokens = [], lastParagraphClipped = false) {
            if (this.options.pedantic) {
              src = src
                .replace(other.tabCharGlobal, '    ')
                .replace(other.spaceLine, '');
            }
            while (src) {
              let token;
              if (
                this.options.extensions?.block?.some(extTokenizer => {
                  if (
                    (token = extTokenizer.call({ lexer: this }, src, tokens))
                  ) {
                    src = src.substring(token.raw.length);
                    tokens.push(token);
                    return true;
                  }
                  return false;
                })
              ) {
                continue;
              }
              // newline
              if ((token = this.tokenizer.space(src))) {
                src = src.substring(token.raw.length);
                const lastToken = tokens.at(-1);
                if (token.raw.length === 1 && lastToken !== undefined) {
                  // if there's a single \n as a spacer, it's terminating the last line,
                  // so move it there so that we don't get unnecessary paragraph tags
                  lastToken.raw += '\n';
                } else {
                  tokens.push(token);
                }
                continue;
              }
              // code
              if ((token = this.tokenizer.code(src))) {
                src = src.substring(token.raw.length);
                const lastToken = tokens.at(-1);
                // An indented code block cannot interrupt a paragraph.
                if (
                  lastToken?.type === 'paragraph' ||
                  lastToken?.type === 'text'
                ) {
                  lastToken.raw += '\n' + token.raw;
                  lastToken.text += '\n' + token.text;
                  this.inlineQueue.at(-1).src = lastToken.text;
                } else {
                  tokens.push(token);
                }
                continue;
              }
              // fences
              if ((token = this.tokenizer.fences(src))) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
              }
              // heading
              if ((token = this.tokenizer.heading(src))) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
              }
              // hr
              if ((token = this.tokenizer.hr(src))) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
              }
              // blockquote
              if ((token = this.tokenizer.blockquote(src))) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
              }
              // list
              if ((token = this.tokenizer.list(src))) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
              }
              // html
              if ((token = this.tokenizer.html(src))) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
              }
              // def
              if ((token = this.tokenizer.def(src))) {
                src = src.substring(token.raw.length);
                const lastToken = tokens.at(-1);
                if (
                  lastToken?.type === 'paragraph' ||
                  lastToken?.type === 'text'
                ) {
                  lastToken.raw += '\n' + token.raw;
                  lastToken.text += '\n' + token.raw;
                  this.inlineQueue.at(-1).src = lastToken.text;
                } else if (!this.tokens.links[token.tag]) {
                  this.tokens.links[token.tag] = {
                    href: token.href,
                    title: token.title
                  };
                }
                continue;
              }
              // table (gfm)
              if ((token = this.tokenizer.table(src))) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
              }
              // lheading
              if ((token = this.tokenizer.lheading(src))) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
              }
              // top-level paragraph
              // prevent paragraph consuming extensions by clipping 'src' to extension start
              let cutSrc = src;
              if (this.options.extensions?.startBlock) {
                let startIndex = Infinity;
                const tempSrc = src.slice(1);
                let tempStart;
                this.options.extensions.startBlock.forEach(getStartIndex => {
                  tempStart = getStartIndex.call({ lexer: this }, tempSrc);
                  if (typeof tempStart === 'number' && tempStart >= 0) {
                    startIndex = Math.min(startIndex, tempStart);
                  }
                });
                if (startIndex < Infinity && startIndex >= 0) {
                  cutSrc = src.substring(0, startIndex + 1);
                }
              }
              if (
                this.state.top &&
                (token = this.tokenizer.paragraph(cutSrc))
              ) {
                const lastToken = tokens.at(-1);
                if (lastParagraphClipped && lastToken?.type === 'paragraph') {
                  lastToken.raw += '\n' + token.raw;
                  lastToken.text += '\n' + token.text;
                  this.inlineQueue.pop();
                  this.inlineQueue.at(-1).src = lastToken.text;
                } else {
                  tokens.push(token);
                }
                lastParagraphClipped = cutSrc.length !== src.length;
                src = src.substring(token.raw.length);
                continue;
              }
              // text
              if ((token = this.tokenizer.text(src))) {
                src = src.substring(token.raw.length);
                const lastToken = tokens.at(-1);
                if (lastToken?.type === 'text') {
                  lastToken.raw += '\n' + token.raw;
                  lastToken.text += '\n' + token.text;
                  this.inlineQueue.pop();
                  this.inlineQueue.at(-1).src = lastToken.text;
                } else {
                  tokens.push(token);
                }
                continue;
              }
              if (src) {
                const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);
                if (this.options.silent) {
                  console.error(errMsg);
                  break;
                } else {
                  throw new Error(errMsg);
                }
              }
            }
            this.state.top = true;
            return tokens;
          }
          inline(src, tokens = []) {
            this.inlineQueue.push({ src, tokens });
            return tokens;
          }
          /**
           * Lexing/Compiling
           */
          inlineTokens(src, tokens = []) {
            // String with links masked to avoid interference with em and strong
            let maskedSrc = src;
            let match = null;
            // Mask out reflinks
            if (this.tokens.links) {
              const links = Object.keys(this.tokens.links);
              if (links.length > 0) {
                while (
                  (match =
                    this.tokenizer.rules.inline.reflinkSearch.exec(
                      maskedSrc
                    )) != null
                ) {
                  if (
                    links.includes(
                      match[0].slice(match[0].lastIndexOf('[') + 1, -1)
                    )
                  ) {
                    maskedSrc =
                      maskedSrc.slice(0, match.index) +
                      '[' +
                      'a'.repeat(match[0].length - 2) +
                      ']' +
                      maskedSrc.slice(
                        this.tokenizer.rules.inline.reflinkSearch.lastIndex
                      );
                  }
                }
              }
            }
            // Mask out other blocks
            while (
              (match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) !=
              null
            ) {
              maskedSrc =
                maskedSrc.slice(0, match.index) +
                '[' +
                'a'.repeat(match[0].length - 2) +
                ']' +
                maskedSrc.slice(
                  this.tokenizer.rules.inline.blockSkip.lastIndex
                );
            }
            // Mask out escaped characters
            while (
              (match =
                this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) !=
              null
            ) {
              maskedSrc =
                maskedSrc.slice(0, match.index) +
                '++' +
                maskedSrc.slice(
                  this.tokenizer.rules.inline.anyPunctuation.lastIndex
                );
            }
            let keepPrevChar = false;
            let prevChar = '';
            while (src) {
              if (!keepPrevChar) {
                prevChar = '';
              }
              keepPrevChar = false;
              let token;
              // extensions
              if (
                this.options.extensions?.inline?.some(extTokenizer => {
                  if (
                    (token = extTokenizer.call({ lexer: this }, src, tokens))
                  ) {
                    src = src.substring(token.raw.length);
                    tokens.push(token);
                    return true;
                  }
                  return false;
                })
              ) {
                continue;
              }
              // escape
              if ((token = this.tokenizer.escape(src))) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
              }
              // tag
              if ((token = this.tokenizer.tag(src))) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
              }
              // link
              if ((token = this.tokenizer.link(src))) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
              }
              // reflink, nolink
              if ((token = this.tokenizer.reflink(src, this.tokens.links))) {
                src = src.substring(token.raw.length);
                const lastToken = tokens.at(-1);
                if (token.type === 'text' && lastToken?.type === 'text') {
                  lastToken.raw += token.raw;
                  lastToken.text += token.text;
                } else {
                  tokens.push(token);
                }
                continue;
              }
              // em & strong
              if ((token = this.tokenizer.emStrong(src, maskedSrc, prevChar))) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
              }
              // code
              if ((token = this.tokenizer.codespan(src))) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
              }
              // br
              if ((token = this.tokenizer.br(src))) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
              }
              // del (gfm)
              if ((token = this.tokenizer.del(src))) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
              }
              // autolink
              if ((token = this.tokenizer.autolink(src))) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
              }
              // url (gfm)
              if (!this.state.inLink && (token = this.tokenizer.url(src))) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
              }
              // text
              // prevent inlineText consuming extensions by clipping 'src' to extension start
              let cutSrc = src;
              if (this.options.extensions?.startInline) {
                let startIndex = Infinity;
                const tempSrc = src.slice(1);
                let tempStart;
                this.options.extensions.startInline.forEach(getStartIndex => {
                  tempStart = getStartIndex.call({ lexer: this }, tempSrc);
                  if (typeof tempStart === 'number' && tempStart >= 0) {
                    startIndex = Math.min(startIndex, tempStart);
                  }
                });
                if (startIndex < Infinity && startIndex >= 0) {
                  cutSrc = src.substring(0, startIndex + 1);
                }
              }
              if ((token = this.tokenizer.inlineText(cutSrc))) {
                src = src.substring(token.raw.length);
                if (token.raw.slice(-1) !== '_') {
                  // Track prevChar before string of ____ started
                  prevChar = token.raw.slice(-1);
                }
                keepPrevChar = true;
                const lastToken = tokens.at(-1);
                if (lastToken?.type === 'text') {
                  lastToken.raw += token.raw;
                  lastToken.text += token.text;
                } else {
                  tokens.push(token);
                }
                continue;
              }
              if (src) {
                const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);
                if (this.options.silent) {
                  console.error(errMsg);
                  break;
                } else {
                  throw new Error(errMsg);
                }
              }
            }
            return tokens;
          }
        }

        /**
         * Renderer
         */
        class _Renderer {
          options;
          parser; // set by the parser
          constructor(options) {
            this.options = options || _defaults;
          }
          space(token) {
            return '';
          }
          code({ text, lang, escaped }) {
            const langString = (lang || '').match(other.notSpaceStart)?.[0];
            const code = text.replace(other.endingNewline, '') + '\n';
            if (!langString) {
              return (
                '<pre><code>' +
                (escaped ? code : escape(code, true)) +
                '</code></pre>\n'
              );
            }
            return (
              '<pre><code class="language-' +
              escape(langString) +
              '">' +
              (escaped ? code : escape(code, true)) +
              '</code></pre>\n'
            );
          }
          blockquote({ tokens }) {
            const body = this.parser.parse(tokens);
            return `<blockquote>\n${body}</blockquote>\n`;
          }
          html({ text }) {
            return text;
          }
          heading({ tokens, depth }) {
            return `<h${depth}>${this.parser.parseInline(tokens)}</h${depth}>\n`;
          }
          hr(token) {
            return '<hr>\n';
          }
          list(token) {
            const ordered = token.ordered;
            const start = token.start;
            let body = '';
            for (let j = 0; j < token.items.length; j++) {
              const item = token.items[j];
              body += this.listitem(item);
            }
            const type = ordered ? 'ol' : 'ul';
            const startAttr =
              ordered && start !== 1 ? ' start="' + start + '"' : '';
            return '<' + type + startAttr + '>\n' + body + '</' + type + '>\n';
          }
          listitem(item) {
            let itemBody = '';
            if (item.task) {
              const checkbox = this.checkbox({ checked: !!item.checked });
              if (item.loose) {
                if (item.tokens[0]?.type === 'paragraph') {
                  item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;
                  if (
                    item.tokens[0].tokens &&
                    item.tokens[0].tokens.length > 0 &&
                    item.tokens[0].tokens[0].type === 'text'
                  ) {
                    item.tokens[0].tokens[0].text =
                      checkbox + ' ' + escape(item.tokens[0].tokens[0].text);
                    item.tokens[0].tokens[0].escaped = true;
                  }
                } else {
                  item.tokens.unshift({
                    type: 'text',
                    raw: checkbox + ' ',
                    text: checkbox + ' ',
                    escaped: true
                  });
                }
              } else {
                itemBody += checkbox + ' ';
              }
            }
            itemBody += this.parser.parse(item.tokens, !!item.loose);
            return `<li>${itemBody}</li>\n`;
          }
          checkbox({ checked }) {
            return (
              '<input ' +
              (checked ? 'checked="" ' : '') +
              'disabled="" type="checkbox">'
            );
          }
          paragraph({ tokens }) {
            return `<p>${this.parser.parseInline(tokens)}</p>\n`;
          }
          table(token) {
            let header = '';
            // header
            let cell = '';
            for (let j = 0; j < token.header.length; j++) {
              cell += this.tablecell(token.header[j]);
            }
            header += this.tablerow({ text: cell });
            let body = '';
            for (let j = 0; j < token.rows.length; j++) {
              const row = token.rows[j];
              cell = '';
              for (let k = 0; k < row.length; k++) {
                cell += this.tablecell(row[k]);
              }
              body += this.tablerow({ text: cell });
            }
            if (body) body = `<tbody>${body}</tbody>`;
            return (
              '<table>\n' +
              '<thead>\n' +
              header +
              '</thead>\n' +
              body +
              '</table>\n'
            );
          }
          tablerow({ text }) {
            return `<tr>\n${text}</tr>\n`;
          }
          tablecell(token) {
            const content = this.parser.parseInline(token.tokens);
            const type = token.header ? 'th' : 'td';
            const tag = token.align
              ? `<${type} align="${token.align}">`
              : `<${type}>`;
            return tag + content + `</${type}>\n`;
          }
          /**
           * span level renderer
           */
          strong({ tokens }) {
            return `<strong>${this.parser.parseInline(tokens)}</strong>`;
          }
          em({ tokens }) {
            return `<em>${this.parser.parseInline(tokens)}</em>`;
          }
          codespan({ text }) {
            return `<code>${escape(text, true)}</code>`;
          }
          br(token) {
            return '<br>';
          }
          del({ tokens }) {
            return `<del>${this.parser.parseInline(tokens)}</del>`;
          }
          link({ href, title, tokens }) {
            const text = this.parser.parseInline(tokens);
            const cleanHref = cleanUrl(href);
            if (cleanHref === null) {
              return text;
            }
            href = cleanHref;
            let out = '<a href="' + href + '"';
            if (title) {
              out += ' title="' + escape(title) + '"';
            }
            out += '>' + text + '</a>';
            return out;
          }
          image({ href, title, text }) {
            const cleanHref = cleanUrl(href);
            if (cleanHref === null) {
              return escape(text);
            }
            href = cleanHref;
            let out = `<img src="${href}" alt="${text}"`;
            if (title) {
              out += ` title="${escape(title)}"`;
            }
            out += '>';
            return out;
          }
          text(token) {
            return 'tokens' in token && token.tokens
              ? this.parser.parseInline(token.tokens)
              : 'escaped' in token && token.escaped
                ? token.text
                : escape(token.text);
          }
        }

        /**
         * TextRenderer
         * returns only the textual part of the token
         */
        class _TextRenderer {
          // no need for block level renderers
          strong({ text }) {
            return text;
          }
          em({ text }) {
            return text;
          }
          codespan({ text }) {
            return text;
          }
          del({ text }) {
            return text;
          }
          html({ text }) {
            return text;
          }
          text({ text }) {
            return text;
          }
          link({ text }) {
            return '' + text;
          }
          image({ text }) {
            return '' + text;
          }
          br() {
            return '';
          }
        }

        /**
         * Parsing & Compiling
         */
        class _Parser {
          options;
          renderer;
          textRenderer;
          constructor(options) {
            this.options = options || _defaults;
            this.options.renderer = this.options.renderer || new _Renderer();
            this.renderer = this.options.renderer;
            this.renderer.options = this.options;
            this.renderer.parser = this;
            this.textRenderer = new _TextRenderer();
          }
          /**
           * Static Parse Method
           */
          static parse(tokens, options) {
            const parser = new _Parser(options);
            return parser.parse(tokens);
          }
          /**
           * Static Parse Inline Method
           */
          static parseInline(tokens, options) {
            const parser = new _Parser(options);
            return parser.parseInline(tokens);
          }
          /**
           * Parse Loop
           */
          parse(tokens, top = true) {
            let out = '';
            for (let i = 0; i < tokens.length; i++) {
              const anyToken = tokens[i];
              // Run any renderer extensions
              if (this.options.extensions?.renderers?.[anyToken.type]) {
                const genericToken = anyToken;
                const ret = this.options.extensions.renderers[
                  genericToken.type
                ].call({ parser: this }, genericToken);
                if (
                  ret !== false ||
                  ![
                    'space',
                    'hr',
                    'heading',
                    'code',
                    'table',
                    'blockquote',
                    'list',
                    'html',
                    'paragraph',
                    'text'
                  ].includes(genericToken.type)
                ) {
                  out += ret || '';
                  continue;
                }
              }
              const token = anyToken;
              switch (token.type) {
                case 'space': {
                  out += this.renderer.space(token);
                  continue;
                }
                case 'hr': {
                  out += this.renderer.hr(token);
                  continue;
                }
                case 'heading': {
                  out += this.renderer.heading(token);
                  continue;
                }
                case 'code': {
                  out += this.renderer.code(token);
                  continue;
                }
                case 'table': {
                  out += this.renderer.table(token);
                  continue;
                }
                case 'blockquote': {
                  out += this.renderer.blockquote(token);
                  continue;
                }
                case 'list': {
                  out += this.renderer.list(token);
                  continue;
                }
                case 'html': {
                  out += this.renderer.html(token);
                  continue;
                }
                case 'paragraph': {
                  out += this.renderer.paragraph(token);
                  continue;
                }
                case 'text': {
                  let textToken = token;
                  let body = this.renderer.text(textToken);
                  while (
                    i + 1 < tokens.length &&
                    tokens[i + 1].type === 'text'
                  ) {
                    textToken = tokens[++i];
                    body += '\n' + this.renderer.text(textToken);
                  }
                  if (top) {
                    out += this.renderer.paragraph({
                      type: 'paragraph',
                      raw: body,
                      text: body,
                      tokens: [
                        { type: 'text', raw: body, text: body, escaped: true }
                      ]
                    });
                  } else {
                    out += body;
                  }
                  continue;
                }
                default: {
                  const errMsg =
                    'Token with "' + token.type + '" type was not found.';
                  if (this.options.silent) {
                    console.error(errMsg);
                    return '';
                  } else {
                    throw new Error(errMsg);
                  }
                }
              }
            }
            return out;
          }
          /**
           * Parse Inline Tokens
           */
          parseInline(tokens, renderer = this.renderer) {
            let out = '';
            for (let i = 0; i < tokens.length; i++) {
              const anyToken = tokens[i];
              // Run any renderer extensions
              if (this.options.extensions?.renderers?.[anyToken.type]) {
                const ret = this.options.extensions.renderers[
                  anyToken.type
                ].call({ parser: this }, anyToken);
                if (
                  ret !== false ||
                  ![
                    'escape',
                    'html',
                    'link',
                    'image',
                    'strong',
                    'em',
                    'codespan',
                    'br',
                    'del',
                    'text'
                  ].includes(anyToken.type)
                ) {
                  out += ret || '';
                  continue;
                }
              }
              const token = anyToken;
              switch (token.type) {
                case 'escape': {
                  out += renderer.text(token);
                  break;
                }
                case 'html': {
                  out += renderer.html(token);
                  break;
                }
                case 'link': {
                  out += renderer.link(token);
                  break;
                }
                case 'image': {
                  out += renderer.image(token);
                  break;
                }
                case 'strong': {
                  out += renderer.strong(token);
                  break;
                }
                case 'em': {
                  out += renderer.em(token);
                  break;
                }
                case 'codespan': {
                  out += renderer.codespan(token);
                  break;
                }
                case 'br': {
                  out += renderer.br(token);
                  break;
                }
                case 'del': {
                  out += renderer.del(token);
                  break;
                }
                case 'text': {
                  out += renderer.text(token);
                  break;
                }
                default: {
                  const errMsg =
                    'Token with "' + token.type + '" type was not found.';
                  if (this.options.silent) {
                    console.error(errMsg);
                    return '';
                  } else {
                    throw new Error(errMsg);
                  }
                }
              }
            }
            return out;
          }
        }

        class _Hooks {
          options;
          block;
          constructor(options) {
            this.options = options || _defaults;
          }
          static passThroughHooks = new Set([
            'preprocess',
            'postprocess',
            'processAllTokens'
          ]);
          /**
           * Process markdown before marked
           */
          preprocess(markdown) {
            return markdown;
          }
          /**
           * Process HTML after marked is finished
           */
          postprocess(html) {
            return html;
          }
          /**
           * Process all tokens before walk tokens
           */
          processAllTokens(tokens) {
            return tokens;
          }
          /**
           * Provide function to tokenize markdown
           */
          provideLexer() {
            return this.block ? _Lexer.lex : _Lexer.lexInline;
          }
          /**
           * Provide function to parse tokens
           */
          provideParser() {
            return this.block ? _Parser.parse : _Parser.parseInline;
          }
        }

        class Marked {
          defaults = _getDefaults();
          options = this.setOptions;
          parse = this.parseMarkdown(true);
          parseInline = this.parseMarkdown(false);
          Parser = _Parser;
          Renderer = _Renderer;
          TextRenderer = _TextRenderer;
          Lexer = _Lexer;
          Tokenizer = _Tokenizer;
          Hooks = _Hooks;
          constructor(...args) {
            this.use(...args);
          }
          /**
           * Run callback for every token
           */
          walkTokens(tokens, callback) {
            let values = [];
            for (const token of tokens) {
              values = values.concat(callback.call(this, token));
              switch (token.type) {
                case 'table': {
                  const tableToken = token;
                  for (const cell of tableToken.header) {
                    values = values.concat(
                      this.walkTokens(cell.tokens, callback)
                    );
                  }
                  for (const row of tableToken.rows) {
                    for (const cell of row) {
                      values = values.concat(
                        this.walkTokens(cell.tokens, callback)
                      );
                    }
                  }
                  break;
                }
                case 'list': {
                  const listToken = token;
                  values = values.concat(
                    this.walkTokens(listToken.items, callback)
                  );
                  break;
                }
                default: {
                  const genericToken = token;
                  if (
                    this.defaults.extensions?.childTokens?.[genericToken.type]
                  ) {
                    this.defaults.extensions.childTokens[
                      genericToken.type
                    ].forEach(childTokens => {
                      const tokens = genericToken[childTokens].flat(Infinity);
                      values = values.concat(this.walkTokens(tokens, callback));
                    });
                  } else if (genericToken.tokens) {
                    values = values.concat(
                      this.walkTokens(genericToken.tokens, callback)
                    );
                  }
                }
              }
            }
            return values;
          }
          use(...args) {
            const extensions = this.defaults.extensions || {
              renderers: {},
              childTokens: {}
            };
            args.forEach(pack => {
              // copy options to new object
              const opts = { ...pack };
              // set async to true if it was set to true before
              opts.async = this.defaults.async || opts.async || false;
              // ==-- Parse "addon" extensions --== //
              if (pack.extensions) {
                pack.extensions.forEach(ext => {
                  if (!ext.name) {
                    throw new Error('extension name required');
                  }
                  if ('renderer' in ext) {
                    // Renderer extensions
                    const prevRenderer = extensions.renderers[ext.name];
                    if (prevRenderer) {
                      // Replace extension with func to run new extension but fall back if false
                      extensions.renderers[ext.name] = function (...args) {
                        let ret = ext.renderer.apply(this, args);
                        if (ret === false) {
                          ret = prevRenderer.apply(this, args);
                        }
                        return ret;
                      };
                    } else {
                      extensions.renderers[ext.name] = ext.renderer;
                    }
                  }
                  if ('tokenizer' in ext) {
                    // Tokenizer Extensions
                    if (
                      !ext.level ||
                      (ext.level !== 'block' && ext.level !== 'inline')
                    ) {
                      throw new Error(
                        "extension level must be 'block' or 'inline'"
                      );
                    }
                    const extLevel = extensions[ext.level];
                    if (extLevel) {
                      extLevel.unshift(ext.tokenizer);
                    } else {
                      extensions[ext.level] = [ext.tokenizer];
                    }
                    if (ext.start) {
                      // Function to check for start of token
                      if (ext.level === 'block') {
                        if (extensions.startBlock) {
                          extensions.startBlock.push(ext.start);
                        } else {
                          extensions.startBlock = [ext.start];
                        }
                      } else if (ext.level === 'inline') {
                        if (extensions.startInline) {
                          extensions.startInline.push(ext.start);
                        } else {
                          extensions.startInline = [ext.start];
                        }
                      }
                    }
                  }
                  if ('childTokens' in ext && ext.childTokens) {
                    // Child tokens to be visited by walkTokens
                    extensions.childTokens[ext.name] = ext.childTokens;
                  }
                });
                opts.extensions = extensions;
              }
              // ==-- Parse "overwrite" extensions --== //
              if (pack.renderer) {
                const renderer =
                  this.defaults.renderer || new _Renderer(this.defaults);
                for (const prop in pack.renderer) {
                  if (!(prop in renderer)) {
                    throw new Error(`renderer '${prop}' does not exist`);
                  }
                  if (['options', 'parser'].includes(prop)) {
                    // ignore options property
                    continue;
                  }
                  const rendererProp = prop;
                  const rendererFunc = pack.renderer[rendererProp];
                  const prevRenderer = renderer[rendererProp];
                  // Replace renderer with func to run extension, but fall back if false
                  renderer[rendererProp] = (...args) => {
                    let ret = rendererFunc.apply(renderer, args);
                    if (ret === false) {
                      ret = prevRenderer.apply(renderer, args);
                    }
                    return ret || '';
                  };
                }
                opts.renderer = renderer;
              }
              if (pack.tokenizer) {
                const tokenizer =
                  this.defaults.tokenizer || new _Tokenizer(this.defaults);
                for (const prop in pack.tokenizer) {
                  if (!(prop in tokenizer)) {
                    throw new Error(`tokenizer '${prop}' does not exist`);
                  }
                  if (['options', 'rules', 'lexer'].includes(prop)) {
                    // ignore options, rules, and lexer properties
                    continue;
                  }
                  const tokenizerProp = prop;
                  const tokenizerFunc = pack.tokenizer[tokenizerProp];
                  const prevTokenizer = tokenizer[tokenizerProp];
                  // Replace tokenizer with func to run extension, but fall back if false
                  // @ts-expect-error cannot type tokenizer function dynamically
                  tokenizer[tokenizerProp] = (...args) => {
                    let ret = tokenizerFunc.apply(tokenizer, args);
                    if (ret === false) {
                      ret = prevTokenizer.apply(tokenizer, args);
                    }
                    return ret;
                  };
                }
                opts.tokenizer = tokenizer;
              }
              // ==-- Parse Hooks extensions --== //
              if (pack.hooks) {
                const hooks = this.defaults.hooks || new _Hooks();
                for (const prop in pack.hooks) {
                  if (!(prop in hooks)) {
                    throw new Error(`hook '${prop}' does not exist`);
                  }
                  if (['options', 'block'].includes(prop)) {
                    // ignore options and block properties
                    continue;
                  }
                  const hooksProp = prop;
                  const hooksFunc = pack.hooks[hooksProp];
                  const prevHook = hooks[hooksProp];
                  if (_Hooks.passThroughHooks.has(prop)) {
                    // @ts-expect-error cannot type hook function dynamically
                    hooks[hooksProp] = arg => {
                      if (this.defaults.async) {
                        return Promise.resolve(hooksFunc.call(hooks, arg)).then(
                          ret => {
                            return prevHook.call(hooks, ret);
                          }
                        );
                      }
                      const ret = hooksFunc.call(hooks, arg);
                      return prevHook.call(hooks, ret);
                    };
                  } else {
                    // @ts-expect-error cannot type hook function dynamically
                    hooks[hooksProp] = (...args) => {
                      let ret = hooksFunc.apply(hooks, args);
                      if (ret === false) {
                        ret = prevHook.apply(hooks, args);
                      }
                      return ret;
                    };
                  }
                }
                opts.hooks = hooks;
              }
              // ==-- Parse WalkTokens extensions --== //
              if (pack.walkTokens) {
                const walkTokens = this.defaults.walkTokens;
                const packWalktokens = pack.walkTokens;
                opts.walkTokens = function (token) {
                  let values = [];
                  values.push(packWalktokens.call(this, token));
                  if (walkTokens) {
                    values = values.concat(walkTokens.call(this, token));
                  }
                  return values;
                };
              }
              this.defaults = { ...this.defaults, ...opts };
            });
            return this;
          }
          setOptions(opt) {
            this.defaults = { ...this.defaults, ...opt };
            return this;
          }
          lexer(src, options) {
            return _Lexer.lex(src, options ?? this.defaults);
          }
          parser(tokens, options) {
            return _Parser.parse(tokens, options ?? this.defaults);
          }
          parseMarkdown(blockType) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const parse = (src, options) => {
              const origOpt = { ...options };
              const opt = { ...this.defaults, ...origOpt };
              const throwError = this.onError(!!opt.silent, !!opt.async);
              // throw error if an extension set async to true but parse was called with async: false
              if (this.defaults.async === true && origOpt.async === false) {
                return throwError(
                  new Error(
                    'marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise.'
                  )
                );
              }
              // throw error in case of non string input
              if (typeof src === 'undefined' || src === null) {
                return throwError(
                  new Error('marked(): input parameter is undefined or null')
                );
              }
              if (typeof src !== 'string') {
                return throwError(
                  new Error(
                    'marked(): input parameter is of type ' +
                      Object.prototype.toString.call(src) +
                      ', string expected'
                  )
                );
              }
              if (opt.hooks) {
                opt.hooks.options = opt;
                opt.hooks.block = blockType;
              }
              const lexer = opt.hooks
                ? opt.hooks.provideLexer()
                : blockType
                  ? _Lexer.lex
                  : _Lexer.lexInline;
              const parser = opt.hooks
                ? opt.hooks.provideParser()
                : blockType
                  ? _Parser.parse
                  : _Parser.parseInline;
              if (opt.async) {
                return Promise.resolve(
                  opt.hooks ? opt.hooks.preprocess(src) : src
                )
                  .then(src => lexer(src, opt))
                  .then(tokens =>
                    opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens
                  )
                  .then(tokens =>
                    opt.walkTokens
                      ? Promise.all(
                          this.walkTokens(tokens, opt.walkTokens)
                        ).then(() => tokens)
                      : tokens
                  )
                  .then(tokens => parser(tokens, opt))
                  .then(html =>
                    opt.hooks ? opt.hooks.postprocess(html) : html
                  )
                  .catch(throwError);
              }
              try {
                if (opt.hooks) {
                  src = opt.hooks.preprocess(src);
                }
                let tokens = lexer(src, opt);
                if (opt.hooks) {
                  tokens = opt.hooks.processAllTokens(tokens);
                }
                if (opt.walkTokens) {
                  this.walkTokens(tokens, opt.walkTokens);
                }
                let html = parser(tokens, opt);
                if (opt.hooks) {
                  html = opt.hooks.postprocess(html);
                }
                return html;
              } catch (e) {
                return throwError(e);
              }
            };
            return parse;
          }
          onError(silent, async) {
            return e => {
              e.message +=
                '\nPlease report this to https://github.com/markedjs/marked.';
              if (silent) {
                const msg =
                  '<p>An error occurred:</p><pre>' +
                  escape(e.message + '', true) +
                  '</pre>';
                if (async) {
                  return Promise.resolve(msg);
                }
                return msg;
              }
              if (async) {
                return Promise.reject(e);
              }
              throw e;
            };
          }
        }

        const markedInstance = new Marked();
        function marked(src, opt) {
          return markedInstance.parse(src, opt);
        }
        /**
         * Sets the default options.
         *
         * @param options Hash of options
         */
        marked.options = marked.setOptions = function (options) {
          markedInstance.setOptions(options);
          marked.defaults = markedInstance.defaults;
          changeDefaults(marked.defaults);
          return marked;
        };
        /**
         * Gets the original marked default options.
         */
        marked.getDefaults = _getDefaults;
        marked.defaults = _defaults;
        /**
         * Use Extension
         */
        marked.use = function (...args) {
          markedInstance.use(...args);
          marked.defaults = markedInstance.defaults;
          changeDefaults(marked.defaults);
          return marked;
        };
        /**
         * Run callback for every token
         */
        marked.walkTokens = function (tokens, callback) {
          return markedInstance.walkTokens(tokens, callback);
        };
        /**
         * Compiles markdown to HTML without enclosing `p` tag.
         *
         * @param src String of markdown source to be compiled
         * @param options Hash of options
         * @return String of compiled HTML
         */
        marked.parseInline = markedInstance.parseInline;
        /**
         * Expose
         */
        marked.Parser = _Parser;
        marked.parser = _Parser.parse;
        marked.Renderer = _Renderer;
        marked.TextRenderer = _TextRenderer;
        marked.Lexer = _Lexer;
        marked.lexer = _Lexer.lex;
        marked.Tokenizer = _Tokenizer;
        marked.Hooks = _Hooks;
        marked.parse = marked;
        const options = marked.options;
        const setOptions = marked.setOptions;
        const use = marked.use;
        const walkTokens = marked.walkTokens;
        const parseInline = marked.parseInline;
        const parse = marked;
        const parser = _Parser.parse;
        const lexer = _Lexer.lex;

        /***/
      },

    /***/ '../../node_modules/process/browser.js':
      /*!*********************************************!*\
  !*** ../../node_modules/process/browser.js ***!
  \*********************************************/
      /***/ module => {
        // shim for using process in browser
        var process = (module.exports = {});

        // cached from whatever global is present so that test runners that stub it
        // don't break things.  But we need to wrap it in a try catch in case it is
        // wrapped in strict mode code which doesn't define any globals.  It's inside a
        // function because try/catches deoptimize in certain engines.

        var cachedSetTimeout;
        var cachedClearTimeout;

        function defaultSetTimout() {
          throw new Error('setTimeout has not been defined');
        }
        function defaultClearTimeout() {
          throw new Error('clearTimeout has not been defined');
        }
        (function () {
          try {
            if (typeof setTimeout === 'function') {
              cachedSetTimeout = setTimeout;
            } else {
              cachedSetTimeout = defaultSetTimout;
            }
          } catch (e) {
            cachedSetTimeout = defaultSetTimout;
          }
          try {
            if (typeof clearTimeout === 'function') {
              cachedClearTimeout = clearTimeout;
            } else {
              cachedClearTimeout = defaultClearTimeout;
            }
          } catch (e) {
            cachedClearTimeout = defaultClearTimeout;
          }
        })();
        function runTimeout(fun) {
          if (cachedSetTimeout === setTimeout) {
            //normal enviroments in sane situations
            return setTimeout(fun, 0);
          }
          // if setTimeout wasn't available but was latter defined
          if (
            (cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) &&
            setTimeout
          ) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
          }
          try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedSetTimeout(fun, 0);
          } catch (e) {
            try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
              return cachedSetTimeout.call(null, fun, 0);
            } catch (e) {
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
              return cachedSetTimeout.call(this, fun, 0);
            }
          }
        }
        function runClearTimeout(marker) {
          if (cachedClearTimeout === clearTimeout) {
            //normal enviroments in sane situations
            return clearTimeout(marker);
          }
          // if clearTimeout wasn't available but was latter defined
          if (
            (cachedClearTimeout === defaultClearTimeout ||
              !cachedClearTimeout) &&
            clearTimeout
          ) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
          }
          try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedClearTimeout(marker);
          } catch (e) {
            try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
              return cachedClearTimeout.call(null, marker);
            } catch (e) {
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
              // Some versions of I.E. have different rules for clearTimeout vs setTimeout
              return cachedClearTimeout.call(this, marker);
            }
          }
        }
        var queue = [];
        var draining = false;
        var currentQueue;
        var queueIndex = -1;

        function cleanUpNextTick() {
          if (!draining || !currentQueue) {
            return;
          }
          draining = false;
          if (currentQueue.length) {
            queue = currentQueue.concat(queue);
          } else {
            queueIndex = -1;
          }
          if (queue.length) {
            drainQueue();
          }
        }

        function drainQueue() {
          if (draining) {
            return;
          }
          var timeout = runTimeout(cleanUpNextTick);
          draining = true;

          var len = queue.length;
          while (len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
              if (currentQueue) {
                currentQueue[queueIndex].run();
              }
            }
            queueIndex = -1;
            len = queue.length;
          }
          currentQueue = null;
          draining = false;
          runClearTimeout(timeout);
        }

        process.nextTick = function (fun) {
          var args = new Array(arguments.length - 1);
          if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
              args[i - 1] = arguments[i];
            }
          }
          queue.push(new Item(fun, args));
          if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
          }
        };

        // v8 likes predictible objects
        function Item(fun, array) {
          this.fun = fun;
          this.array = array;
        }
        Item.prototype.run = function () {
          this.fun.apply(null, this.array);
        };
        process.title = 'browser';
        process.browser = true;
        process.env = {};
        process.argv = [];
        process.version = ''; // empty string to avoid regexp issues
        process.versions = {};

        function noop() {}

        process.on = noop;
        process.addListener = noop;
        process.once = noop;
        process.off = noop;
        process.removeListener = noop;
        process.removeAllListeners = noop;
        process.emit = noop;
        process.prependListener = noop;
        process.prependOnceListener = noop;

        process.listeners = function (name) {
          return [];
        };

        process.binding = function (name) {
          throw new Error('process.binding is not supported');
        };

        process.cwd = function () {
          return '/';
        };
        process.chdir = function (dir) {
          throw new Error('process.chdir is not supported');
        };
        process.umask = function () {
          return 0;
        };

        /***/
      },

    /***/ '../../node_modules/regenerator-runtime/runtime.js':
      /*!*********************************************************!*\
  !*** ../../node_modules/regenerator-runtime/runtime.js ***!
  \*********************************************************/
      /***/ module => {
        /**
         * Copyright (c) 2014-present, Facebook, Inc.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */

        var runtime = (function (exports) {
          'use strict';

          var Op = Object.prototype;
          var hasOwn = Op.hasOwnProperty;
          var defineProperty =
            Object.defineProperty ||
            function (obj, key, desc) {
              obj[key] = desc.value;
            };
          var undefined; // More compressible than void 0.
          var $Symbol = typeof Symbol === 'function' ? Symbol : {};
          var iteratorSymbol = $Symbol.iterator || '@@iterator';
          var asyncIteratorSymbol = $Symbol.asyncIterator || '@@asyncIterator';
          var toStringTagSymbol = $Symbol.toStringTag || '@@toStringTag';

          function define(obj, key, value) {
            Object.defineProperty(obj, key, {
              value: value,
              enumerable: true,
              configurable: true,
              writable: true
            });
            return obj[key];
          }
          try {
            // IE 8 has a broken Object.defineProperty that only works on DOM objects.
            define({}, '');
          } catch (err) {
            define = function (obj, key, value) {
              return (obj[key] = value);
            };
          }

          function wrap(innerFn, outerFn, self, tryLocsList) {
            // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
            var protoGenerator =
              outerFn && outerFn.prototype instanceof Generator
                ? outerFn
                : Generator;
            var generator = Object.create(protoGenerator.prototype);
            var context = new Context(tryLocsList || []);

            // The ._invoke method unifies the implementations of the .next,
            // .throw, and .return methods.
            defineProperty(generator, '_invoke', {
              value: makeInvokeMethod(innerFn, self, context)
            });

            return generator;
          }
          exports.wrap = wrap;

          // Try/catch helper to minimize deoptimizations. Returns a completion
          // record like context.tryEntries[i].completion. This interface could
          // have been (and was previously) designed to take a closure to be
          // invoked without arguments, but in all the cases we care about we
          // already have an existing method we want to call, so there's no need
          // to create a new function object. We can even get away with assuming
          // the method takes exactly one argument, since that happens to be true
          // in every case, so we don't have to touch the arguments object. The
          // only additional allocation required is the completion record, which
          // has a stable shape and so hopefully should be cheap to allocate.
          function tryCatch(fn, obj, arg) {
            try {
              return { type: 'normal', arg: fn.call(obj, arg) };
            } catch (err) {
              return { type: 'throw', arg: err };
            }
          }

          var GenStateSuspendedStart = 'suspendedStart';
          var GenStateSuspendedYield = 'suspendedYield';
          var GenStateExecuting = 'executing';
          var GenStateCompleted = 'completed';

          // Returning this object from the innerFn has the same effect as
          // breaking out of the dispatch switch statement.
          var ContinueSentinel = {};

          // Dummy constructor functions that we use as the .constructor and
          // .constructor.prototype properties for functions that return Generator
          // objects. For full spec compliance, you may wish to configure your
          // minifier not to mangle the names of these two functions.
          function Generator() {}
          function GeneratorFunction() {}
          function GeneratorFunctionPrototype() {}

          // This is a polyfill for %IteratorPrototype% for environments that
          // don't natively support it.
          var IteratorPrototype = {};
          define(IteratorPrototype, iteratorSymbol, function () {
            return this;
          });

          var getProto = Object.getPrototypeOf;
          var NativeIteratorPrototype =
            getProto && getProto(getProto(values([])));
          if (
            NativeIteratorPrototype &&
            NativeIteratorPrototype !== Op &&
            hasOwn.call(NativeIteratorPrototype, iteratorSymbol)
          ) {
            // This environment has a native %IteratorPrototype%; use it instead
            // of the polyfill.
            IteratorPrototype = NativeIteratorPrototype;
          }

          var Gp =
            (GeneratorFunctionPrototype.prototype =
            Generator.prototype =
              Object.create(IteratorPrototype));
          GeneratorFunction.prototype = GeneratorFunctionPrototype;
          defineProperty(Gp, 'constructor', {
            value: GeneratorFunctionPrototype,
            configurable: true
          });
          defineProperty(GeneratorFunctionPrototype, 'constructor', {
            value: GeneratorFunction,
            configurable: true
          });
          GeneratorFunction.displayName = define(
            GeneratorFunctionPrototype,
            toStringTagSymbol,
            'GeneratorFunction'
          );

          // Helper for defining the .next, .throw, and .return methods of the
          // Iterator interface in terms of a single ._invoke method.
          function defineIteratorMethods(prototype) {
            ['next', 'throw', 'return'].forEach(function (method) {
              define(prototype, method, function (arg) {
                return this._invoke(method, arg);
              });
            });
          }

          exports.isGeneratorFunction = function (genFun) {
            var ctor = typeof genFun === 'function' && genFun.constructor;
            return ctor
              ? ctor === GeneratorFunction ||
                  // For the native GeneratorFunction constructor, the best we can
                  // do is to check its .name property.
                  (ctor.displayName || ctor.name) === 'GeneratorFunction'
              : false;
          };

          exports.mark = function (genFun) {
            if (Object.setPrototypeOf) {
              Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
            } else {
              genFun.__proto__ = GeneratorFunctionPrototype;
              define(genFun, toStringTagSymbol, 'GeneratorFunction');
            }
            genFun.prototype = Object.create(Gp);
            return genFun;
          };

          // Within the body of any async function, `await x` is transformed to
          // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
          // `hasOwn.call(value, "__await")` to determine if the yielded value is
          // meant to be awaited.
          exports.awrap = function (arg) {
            return { __await: arg };
          };

          function AsyncIterator(generator, PromiseImpl) {
            function invoke(method, arg, resolve, reject) {
              var record = tryCatch(generator[method], generator, arg);
              if (record.type === 'throw') {
                reject(record.arg);
              } else {
                var result = record.arg;
                var value = result.value;
                if (
                  value &&
                  typeof value === 'object' &&
                  hasOwn.call(value, '__await')
                ) {
                  return PromiseImpl.resolve(value.__await).then(
                    function (value) {
                      invoke('next', value, resolve, reject);
                    },
                    function (err) {
                      invoke('throw', err, resolve, reject);
                    }
                  );
                }

                return PromiseImpl.resolve(value).then(
                  function (unwrapped) {
                    // When a yielded Promise is resolved, its final value becomes
                    // the .value of the Promise<{value,done}> result for the
                    // current iteration.
                    result.value = unwrapped;
                    resolve(result);
                  },
                  function (error) {
                    // If a rejected Promise was yielded, throw the rejection back
                    // into the async generator function so it can be handled there.
                    return invoke('throw', error, resolve, reject);
                  }
                );
              }
            }

            var previousPromise;

            function enqueue(method, arg) {
              function callInvokeWithMethodAndArg() {
                return new PromiseImpl(function (resolve, reject) {
                  invoke(method, arg, resolve, reject);
                });
              }

              return (previousPromise =
                // If enqueue has been called before, then we want to wait until
                // all previous Promises have been resolved before calling invoke,
                // so that results are always delivered in the correct order. If
                // enqueue has not been called before, then it is important to
                // call invoke immediately, without waiting on a callback to fire,
                // so that the async generator function has the opportunity to do
                // any necessary setup in a predictable way. This predictability
                // is why the Promise constructor synchronously invokes its
                // executor callback, and why async functions synchronously
                // execute code before the first await. Since we implement simple
                // async functions in terms of async generators, it is especially
                // important to get this right, even though it requires care.
                previousPromise
                  ? previousPromise.then(
                      callInvokeWithMethodAndArg,
                      // Avoid propagating failures to Promises returned by later
                      // invocations of the iterator.
                      callInvokeWithMethodAndArg
                    )
                  : callInvokeWithMethodAndArg());
            }

            // Define the unified helper method that is used to implement .next,
            // .throw, and .return (see defineIteratorMethods).
            defineProperty(this, '_invoke', { value: enqueue });
          }

          defineIteratorMethods(AsyncIterator.prototype);
          define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
            return this;
          });
          exports.AsyncIterator = AsyncIterator;

          // Note that simple async functions are implemented on top of
          // AsyncIterator objects; they just return a Promise for the value of
          // the final result produced by the iterator.
          exports.async = function (
            innerFn,
            outerFn,
            self,
            tryLocsList,
            PromiseImpl
          ) {
            if (PromiseImpl === void 0) PromiseImpl = Promise;

            var iter = new AsyncIterator(
              wrap(innerFn, outerFn, self, tryLocsList),
              PromiseImpl
            );

            return exports.isGeneratorFunction(outerFn)
              ? iter // If outerFn is a generator, return the full iterator.
              : iter.next().then(function (result) {
                  return result.done ? result.value : iter.next();
                });
          };

          function makeInvokeMethod(innerFn, self, context) {
            var state = GenStateSuspendedStart;

            return function invoke(method, arg) {
              if (state === GenStateExecuting) {
                throw new Error('Generator is already running');
              }

              if (state === GenStateCompleted) {
                if (method === 'throw') {
                  throw arg;
                }

                // Be forgiving, per 25.3.3.3.3 of the spec:
                // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
                return doneResult();
              }

              context.method = method;
              context.arg = arg;

              while (true) {
                var delegate = context.delegate;
                if (delegate) {
                  var delegateResult = maybeInvokeDelegate(delegate, context);
                  if (delegateResult) {
                    if (delegateResult === ContinueSentinel) continue;
                    return delegateResult;
                  }
                }

                if (context.method === 'next') {
                  // Setting context._sent for legacy support of Babel's
                  // function.sent implementation.
                  context.sent = context._sent = context.arg;
                } else if (context.method === 'throw') {
                  if (state === GenStateSuspendedStart) {
                    state = GenStateCompleted;
                    throw context.arg;
                  }

                  context.dispatchException(context.arg);
                } else if (context.method === 'return') {
                  context.abrupt('return', context.arg);
                }

                state = GenStateExecuting;

                var record = tryCatch(innerFn, self, context);
                if (record.type === 'normal') {
                  // If an exception is thrown from innerFn, we leave state ===
                  // GenStateExecuting and loop back for another invocation.
                  state = context.done
                    ? GenStateCompleted
                    : GenStateSuspendedYield;

                  if (record.arg === ContinueSentinel) {
                    continue;
                  }

                  return {
                    value: record.arg,
                    done: context.done
                  };
                } else if (record.type === 'throw') {
                  state = GenStateCompleted;
                  // Dispatch the exception by looping back around to the
                  // context.dispatchException(context.arg) call above.
                  context.method = 'throw';
                  context.arg = record.arg;
                }
              }
            };
          }

          // Call delegate.iterator[context.method](context.arg) and handle the
          // result, either by returning a { value, done } result from the
          // delegate iterator, or by modifying context.method and context.arg,
          // setting context.delegate to null, and returning the ContinueSentinel.
          function maybeInvokeDelegate(delegate, context) {
            var methodName = context.method;
            var method = delegate.iterator[methodName];
            if (method === undefined) {
              // A .throw or .return when the delegate iterator has no .throw
              // method, or a missing .next mehtod, always terminate the
              // yield* loop.
              context.delegate = null;

              // Note: ["return"] must be used for ES3 parsing compatibility.
              if (methodName === 'throw' && delegate.iterator['return']) {
                // If the delegate iterator has a return method, give it a
                // chance to clean up.
                context.method = 'return';
                context.arg = undefined;
                maybeInvokeDelegate(delegate, context);

                if (context.method === 'throw') {
                  // If maybeInvokeDelegate(context) changed context.method from
                  // "return" to "throw", let that override the TypeError below.
                  return ContinueSentinel;
                }
              }
              if (methodName !== 'return') {
                context.method = 'throw';
                context.arg = new TypeError(
                  "The iterator does not provide a '" + methodName + "' method"
                );
              }

              return ContinueSentinel;
            }

            var record = tryCatch(method, delegate.iterator, context.arg);

            if (record.type === 'throw') {
              context.method = 'throw';
              context.arg = record.arg;
              context.delegate = null;
              return ContinueSentinel;
            }

            var info = record.arg;

            if (!info) {
              context.method = 'throw';
              context.arg = new TypeError('iterator result is not an object');
              context.delegate = null;
              return ContinueSentinel;
            }

            if (info.done) {
              // Assign the result of the finished delegate to the temporary
              // variable specified by delegate.resultName (see delegateYield).
              context[delegate.resultName] = info.value;

              // Resume execution at the desired location (see delegateYield).
              context.next = delegate.nextLoc;

              // If context.method was "throw" but the delegate handled the
              // exception, let the outer generator proceed normally. If
              // context.method was "next", forget context.arg since it has been
              // "consumed" by the delegate iterator. If context.method was
              // "return", allow the original .return call to continue in the
              // outer generator.
              if (context.method !== 'return') {
                context.method = 'next';
                context.arg = undefined;
              }
            } else {
              // Re-yield the result returned by the delegate method.
              return info;
            }

            // The delegate iterator is finished, so forget it and continue with
            // the outer generator.
            context.delegate = null;
            return ContinueSentinel;
          }

          // Define Generator.prototype.{next,throw,return} in terms of the
          // unified ._invoke helper method.
          defineIteratorMethods(Gp);

          define(Gp, toStringTagSymbol, 'Generator');

          // A Generator should always return itself as the iterator object when the
          // @@iterator function is called on it. Some browsers' implementations of the
          // iterator prototype chain incorrectly implement this, causing the Generator
          // object to not be returned from this call. This ensures that doesn't happen.
          // See https://github.com/facebook/regenerator/issues/274 for more details.
          define(Gp, iteratorSymbol, function () {
            return this;
          });

          define(Gp, 'toString', function () {
            return '[object Generator]';
          });

          function pushTryEntry(locs) {
            var entry = { tryLoc: locs[0] };

            if (1 in locs) {
              entry.catchLoc = locs[1];
            }

            if (2 in locs) {
              entry.finallyLoc = locs[2];
              entry.afterLoc = locs[3];
            }

            this.tryEntries.push(entry);
          }

          function resetTryEntry(entry) {
            var record = entry.completion || {};
            record.type = 'normal';
            delete record.arg;
            entry.completion = record;
          }

          function Context(tryLocsList) {
            // The root entry object (effectively a try statement without a catch
            // or a finally block) gives us a place to store values thrown from
            // locations where there is no enclosing try statement.
            this.tryEntries = [{ tryLoc: 'root' }];
            tryLocsList.forEach(pushTryEntry, this);
            this.reset(true);
          }

          exports.keys = function (val) {
            var object = Object(val);
            var keys = [];
            for (var key in object) {
              keys.push(key);
            }
            keys.reverse();

            // Rather than returning an object with a next method, we keep
            // things simple and return the next function itself.
            return function next() {
              while (keys.length) {
                var key = keys.pop();
                if (key in object) {
                  next.value = key;
                  next.done = false;
                  return next;
                }
              }

              // To avoid creating an additional object, we just hang the .value
              // and .done properties off the next function object itself. This
              // also ensures that the minifier will not anonymize the function.
              next.done = true;
              return next;
            };
          };

          function values(iterable) {
            if (iterable) {
              var iteratorMethod = iterable[iteratorSymbol];
              if (iteratorMethod) {
                return iteratorMethod.call(iterable);
              }

              if (typeof iterable.next === 'function') {
                return iterable;
              }

              if (!isNaN(iterable.length)) {
                var i = -1,
                  next = function next() {
                    while (++i < iterable.length) {
                      if (hasOwn.call(iterable, i)) {
                        next.value = iterable[i];
                        next.done = false;
                        return next;
                      }
                    }

                    next.value = undefined;
                    next.done = true;

                    return next;
                  };

                return (next.next = next);
              }
            }

            // Return an iterator with no values.
            return { next: doneResult };
          }
          exports.values = values;

          function doneResult() {
            return { value: undefined, done: true };
          }

          Context.prototype = {
            constructor: Context,

            reset: function (skipTempReset) {
              this.prev = 0;
              this.next = 0;
              // Resetting context._sent for legacy support of Babel's
              // function.sent implementation.
              this.sent = this._sent = undefined;
              this.done = false;
              this.delegate = null;

              this.method = 'next';
              this.arg = undefined;

              this.tryEntries.forEach(resetTryEntry);

              if (!skipTempReset) {
                for (var name in this) {
                  // Not sure about the optimal order of these conditions:
                  if (
                    name.charAt(0) === 't' &&
                    hasOwn.call(this, name) &&
                    !isNaN(+name.slice(1))
                  ) {
                    this[name] = undefined;
                  }
                }
              }
            },

            stop: function () {
              this.done = true;

              var rootEntry = this.tryEntries[0];
              var rootRecord = rootEntry.completion;
              if (rootRecord.type === 'throw') {
                throw rootRecord.arg;
              }

              return this.rval;
            },

            dispatchException: function (exception) {
              if (this.done) {
                throw exception;
              }

              var context = this;
              function handle(loc, caught) {
                record.type = 'throw';
                record.arg = exception;
                context.next = loc;

                if (caught) {
                  // If the dispatched exception was caught by a catch block,
                  // then let that catch block handle the exception normally.
                  context.method = 'next';
                  context.arg = undefined;
                }

                return !!caught;
              }

              for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                var entry = this.tryEntries[i];
                var record = entry.completion;

                if (entry.tryLoc === 'root') {
                  // Exception thrown outside of any try block that could handle
                  // it, so set the completion value of the entire function to
                  // throw the exception.
                  return handle('end');
                }

                if (entry.tryLoc <= this.prev) {
                  var hasCatch = hasOwn.call(entry, 'catchLoc');
                  var hasFinally = hasOwn.call(entry, 'finallyLoc');

                  if (hasCatch && hasFinally) {
                    if (this.prev < entry.catchLoc) {
                      return handle(entry.catchLoc, true);
                    } else if (this.prev < entry.finallyLoc) {
                      return handle(entry.finallyLoc);
                    }
                  } else if (hasCatch) {
                    if (this.prev < entry.catchLoc) {
                      return handle(entry.catchLoc, true);
                    }
                  } else if (hasFinally) {
                    if (this.prev < entry.finallyLoc) {
                      return handle(entry.finallyLoc);
                    }
                  } else {
                    throw new Error('try statement without catch or finally');
                  }
                }
              }
            },

            abrupt: function (type, arg) {
              for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                var entry = this.tryEntries[i];
                if (
                  entry.tryLoc <= this.prev &&
                  hasOwn.call(entry, 'finallyLoc') &&
                  this.prev < entry.finallyLoc
                ) {
                  var finallyEntry = entry;
                  break;
                }
              }

              if (
                finallyEntry &&
                (type === 'break' || type === 'continue') &&
                finallyEntry.tryLoc <= arg &&
                arg <= finallyEntry.finallyLoc
              ) {
                // Ignore the finally entry if control is not jumping to a
                // location outside the try/catch block.
                finallyEntry = null;
              }

              var record = finallyEntry ? finallyEntry.completion : {};
              record.type = type;
              record.arg = arg;

              if (finallyEntry) {
                this.method = 'next';
                this.next = finallyEntry.finallyLoc;
                return ContinueSentinel;
              }

              return this.complete(record);
            },

            complete: function (record, afterLoc) {
              if (record.type === 'throw') {
                throw record.arg;
              }

              if (record.type === 'break' || record.type === 'continue') {
                this.next = record.arg;
              } else if (record.type === 'return') {
                this.rval = this.arg = record.arg;
                this.method = 'return';
                this.next = 'end';
              } else if (record.type === 'normal' && afterLoc) {
                this.next = afterLoc;
              }

              return ContinueSentinel;
            },

            finish: function (finallyLoc) {
              for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                var entry = this.tryEntries[i];
                if (entry.finallyLoc === finallyLoc) {
                  this.complete(entry.completion, entry.afterLoc);
                  resetTryEntry(entry);
                  return ContinueSentinel;
                }
              }
            },

            catch: function (tryLoc) {
              for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                var entry = this.tryEntries[i];
                if (entry.tryLoc === tryLoc) {
                  var record = entry.completion;
                  if (record.type === 'throw') {
                    var thrown = record.arg;
                    resetTryEntry(entry);
                  }
                  return thrown;
                }
              }

              // The context.catch method must only be called with a location
              // argument that corresponds to a known catch block.
              throw new Error('illegal catch attempt');
            },

            delegateYield: function (iterable, resultName, nextLoc) {
              this.delegate = {
                iterator: values(iterable),
                resultName: resultName,
                nextLoc: nextLoc
              };

              if (this.method === 'next') {
                // Deliberately forget the last sent value so that we don't
                // accidentally pass it on to the delegate.
                this.arg = undefined;
              }

              return ContinueSentinel;
            }
          };

          // Regardless of whether this script is executing as a CommonJS module
          // or not, return the runtime object so that we can declare the variable
          // regeneratorRuntime in the outer scope, which allows this module to be
          // injected easily by `bin/regenerator --include-runtime script.js`.
          return exports;
        })(
          // If this script is executing as a CommonJS module, use module.exports
          // as the regeneratorRuntime namespace. Otherwise create a new empty
          // object. Either way, the resulting object will be used to initialize
          // the regeneratorRuntime variable at the top of this file.
          true ? module.exports : 0
        );

        try {
          regeneratorRuntime = runtime;
        } catch (accidentalStrictMode) {
          // This module should not be running in strict mode, so the above
          // assignment should always work unless something is misconfigured. Just
          // in case runtime.js accidentally runs in strict mode, in modern engines
          // we can explicitly access globalThis. In older engines we can escape
          // strict mode using a global Function call. This could conceivably fail
          // if a Content Security Policy forbids using Function, but in that case
          // the proper solution is to fix the accidental strict mode problem. If
          // you've misconfigured your bundler to force strict mode and applied a
          // CSP to forbid Function, and you're not willing to fix either of those
          // problems, please detail your unique predicament in a GitHub issue.
          if (typeof globalThis === 'object') {
            globalThis.regeneratorRuntime = runtime;
          } else {
            Function('r', 'regeneratorRuntime = r')(runtime);
          }
        }

        /***/
      },

    /***/ '../../node_modules/tesseract.js/package.json':
      /*!****************************************************!*\
  !*** ../../node_modules/tesseract.js/package.json ***!
  \****************************************************/
      /***/ module => {
        'use strict';
        module.exports = /*#__PURE__*/ JSON.parse(
          '{"name":"tesseract.js","version":"6.0.1","description":"Pure Javascript Multilingual OCR","main":"src/index.js","type":"commonjs","types":"src/index.d.ts","unpkg":"dist/tesseract.min.js","jsdelivr":"dist/tesseract.min.js","scripts":{"start":"node scripts/server.js","build":"rimraf dist && webpack --config scripts/webpack.config.prod.js && rollup -c scripts/rollup.esm.mjs","profile:tesseract":"webpack-bundle-analyzer dist/tesseract-stats.json","profile:worker":"webpack-bundle-analyzer dist/worker-stats.json","prepublishOnly":"npm run build","wait":"rimraf dist && wait-on http://localhost:3000/dist/tesseract.min.js","test":"npm-run-all -p -r start test:all","test:all":"npm-run-all wait test:browser test:node:all","test:browser":"karma start karma.conf.js","test:node":"nyc mocha --exit --bail --require ./scripts/test-helper.mjs","test:node:all":"npm run test:node -- ./tests/*.test.mjs","lint":"eslint src","lint:fix":"eslint --fix src","postinstall":"opencollective-postinstall || true"},"browser":{"./src/worker/node/index.js":"./src/worker/browser/index.js"},"author":"","contributors":["jeromewu"],"license":"Apache-2.0","devDependencies":{"@babel/core":"^7.21.4","@babel/eslint-parser":"^7.21.3","@babel/preset-env":"^7.21.4","@rollup/plugin-commonjs":"^24.1.0","acorn":"^8.8.2","babel-loader":"^9.1.2","buffer":"^6.0.3","cors":"^2.8.5","eslint":"^7.32.0","eslint-config-airbnb-base":"^14.2.1","eslint-plugin-import":"^2.27.5","expect.js":"^0.3.1","express":"^4.18.2","mocha":"^10.2.0","npm-run-all":"^4.1.5","karma":"^6.4.2","karma-chrome-launcher":"^3.2.0","karma-firefox-launcher":"^2.1.2","karma-mocha":"^2.0.1","karma-webpack":"^5.0.0","nyc":"^15.1.0","rimraf":"^5.0.0","rollup":"^3.20.7","wait-on":"^7.0.1","webpack":"^5.79.0","webpack-bundle-analyzer":"^4.8.0","webpack-cli":"^5.0.1","webpack-dev-middleware":"^6.0.2","rollup-plugin-sourcemaps":"^0.6.3"},"dependencies":{"bmp-js":"^0.1.0","idb-keyval":"^6.2.0","is-url":"^1.2.4","node-fetch":"^2.6.9","opencollective-postinstall":"^2.0.3","regenerator-runtime":"^0.13.3","tesseract.js-core":"^6.0.0","wasm-feature-detect":"^1.2.11","zlibjs":"^0.3.1"},"overrides":{"@rollup/pluginutils":"^5.0.2"},"repository":{"type":"git","url":"https://github.com/naptha/tesseract.js.git"},"bugs":{"url":"https://github.com/naptha/tesseract.js/issues"},"homepage":"https://github.com/naptha/tesseract.js","collective":{"type":"opencollective","url":"https://opencollective.com/tesseractjs"}}'
        );

        /***/
      },

    /***/ '../../node_modules/tesseract.js/src/Tesseract.js':
      /*!********************************************************!*\
  !*** ../../node_modules/tesseract.js/src/Tesseract.js ***!
  \********************************************************/
      /***/ (module, __unused_webpack_exports, __webpack_require__) => {
        'use strict';

        const createWorker = __webpack_require__(
          /*! ./createWorker */ '../../node_modules/tesseract.js/src/createWorker.js'
        );

        const recognize = async (image, langs, options) => {
          const worker = await createWorker(langs, 1, options);
          return worker.recognize(image).finally(async () => {
            await worker.terminate();
          });
        };

        const detect = async (image, options) => {
          const worker = await createWorker('osd', 0, options);
          return worker.detect(image).finally(async () => {
            await worker.terminate();
          });
        };

        module.exports = {
          recognize,
          detect
        };

        /***/
      },

    /***/ '../../node_modules/tesseract.js/src/constants/OEM.js':
      /*!************************************************************!*\
  !*** ../../node_modules/tesseract.js/src/constants/OEM.js ***!
  \************************************************************/
      /***/ module => {
        'use strict';

        /*
         * OEM = OCR Engine Mode, and there are 4 possible modes.
         *
         * By default tesseract.js uses LSTM_ONLY mode.
         *
         */
        module.exports = {
          TESSERACT_ONLY: 0,
          LSTM_ONLY: 1,
          TESSERACT_LSTM_COMBINED: 2,
          DEFAULT: 3
        };

        /***/
      },

    /***/ '../../node_modules/tesseract.js/src/constants/PSM.js':
      /*!************************************************************!*\
  !*** ../../node_modules/tesseract.js/src/constants/PSM.js ***!
  \************************************************************/
      /***/ module => {
        'use strict';

        /*
         * PSM = Page Segmentation Mode
         */
        module.exports = {
          OSD_ONLY: '0',
          AUTO_OSD: '1',
          AUTO_ONLY: '2',
          AUTO: '3',
          SINGLE_COLUMN: '4',
          SINGLE_BLOCK_VERT_TEXT: '5',
          SINGLE_BLOCK: '6',
          SINGLE_LINE: '7',
          SINGLE_WORD: '8',
          CIRCLE_WORD: '9',
          SINGLE_CHAR: '10',
          SPARSE_TEXT: '11',
          SPARSE_TEXT_OSD: '12',
          RAW_LINE: '13'
        };

        /***/
      },

    /***/ '../../node_modules/tesseract.js/src/constants/defaultOptions.js':
      /*!***********************************************************************!*\
  !*** ../../node_modules/tesseract.js/src/constants/defaultOptions.js ***!
  \***********************************************************************/
      /***/ module => {
        'use strict';

        module.exports = {
          /*
           * Use BlobURL for worker script by default
           * TODO: remove this option
           *
           */
          workerBlobURL: true,
          logger: () => {}
        };

        /***/
      },

    /***/ '../../node_modules/tesseract.js/src/constants/languages.js':
      /*!******************************************************************!*\
  !*** ../../node_modules/tesseract.js/src/constants/languages.js ***!
  \******************************************************************/
      /***/ module => {
        'use strict';

        /*
         * languages with existing tesseract traineddata
         * https://tesseract-ocr.github.io/tessdoc/Data-Files#data-files-for-version-400-november-29-2016
         */

        /**
         * @typedef {object} Languages
         * @property {string} AFR Afrikaans
         * @property {string} AMH Amharic
         * @property {string} ARA Arabic
         * @property {string} ASM Assamese
         * @property {string} AZE Azerbaijani
         * @property {string} AZE_CYRL Azerbaijani - Cyrillic
         * @property {string} BEL Belarusian
         * @property {string} BEN Bengali
         * @property {string} BOD Tibetan
         * @property {string} BOS Bosnian
         * @property {string} BUL Bulgarian
         * @property {string} CAT Catalan; Valencian
         * @property {string} CEB Cebuano
         * @property {string} CES Czech
         * @property {string} CHI_SIM Chinese - Simplified
         * @property {string} CHI_TRA Chinese - Traditional
         * @property {string} CHR Cherokee
         * @property {string} CYM Welsh
         * @property {string} DAN Danish
         * @property {string} DEU German
         * @property {string} DZO Dzongkha
         * @property {string} ELL Greek, Modern (1453-)
         * @property {string} ENG English
         * @property {string} ENM English, Middle (1100-1500)
         * @property {string} EPO Esperanto
         * @property {string} EST Estonian
         * @property {string} EUS Basque
         * @property {string} FAS Persian
         * @property {string} FIN Finnish
         * @property {string} FRA French
         * @property {string} FRK German Fraktur
         * @property {string} FRM French, Middle (ca. 1400-1600)
         * @property {string} GLE Irish
         * @property {string} GLG Galician
         * @property {string} GRC Greek, Ancient (-1453)
         * @property {string} GUJ Gujarati
         * @property {string} HAT Haitian; Haitian Creole
         * @property {string} HEB Hebrew
         * @property {string} HIN Hindi
         * @property {string} HRV Croatian
         * @property {string} HUN Hungarian
         * @property {string} IKU Inuktitut
         * @property {string} IND Indonesian
         * @property {string} ISL Icelandic
         * @property {string} ITA Italian
         * @property {string} ITA_OLD Italian - Old
         * @property {string} JAV Javanese
         * @property {string} JPN Japanese
         * @property {string} KAN Kannada
         * @property {string} KAT Georgian
         * @property {string} KAT_OLD Georgian - Old
         * @property {string} KAZ Kazakh
         * @property {string} KHM Central Khmer
         * @property {string} KIR Kirghiz; Kyrgyz
         * @property {string} KOR Korean
         * @property {string} KUR Kurdish
         * @property {string} LAO Lao
         * @property {string} LAT Latin
         * @property {string} LAV Latvian
         * @property {string} LIT Lithuanian
         * @property {string} MAL Malayalam
         * @property {string} MAR Marathi
         * @property {string} MKD Macedonian
         * @property {string} MLT Maltese
         * @property {string} MSA Malay
         * @property {string} MYA Burmese
         * @property {string} NEP Nepali
         * @property {string} NLD Dutch; Flemish
         * @property {string} NOR Norwegian
         * @property {string} ORI Oriya
         * @property {string} PAN Panjabi; Punjabi
         * @property {string} POL Polish
         * @property {string} POR Portuguese
         * @property {string} PUS Pushto; Pashto
         * @property {string} RON Romanian; Moldavian; Moldovan
         * @property {string} RUS Russian
         * @property {string} SAN Sanskrit
         * @property {string} SIN Sinhala; Sinhalese
         * @property {string} SLK Slovak
         * @property {string} SLV Slovenian
         * @property {string} SPA Spanish; Castilian
         * @property {string} SPA_OLD Spanish; Castilian - Old
         * @property {string} SQI Albanian
         * @property {string} SRP Serbian
         * @property {string} SRP_LATN Serbian - Latin
         * @property {string} SWA Swahili
         * @property {string} SWE Swedish
         * @property {string} SYR Syriac
         * @property {string} TAM Tamil
         * @property {string} TEL Telugu
         * @property {string} TGK Tajik
         * @property {string} TGL Tagalog
         * @property {string} THA Thai
         * @property {string} TIR Tigrinya
         * @property {string} TUR Turkish
         * @property {string} UIG Uighur; Uyghur
         * @property {string} UKR Ukrainian
         * @property {string} URD Urdu
         * @property {string} UZB Uzbek
         * @property {string} UZB_CYRL Uzbek - Cyrillic
         * @property {string} VIE Vietnamese
         * @property {string} YID Yiddish
         */

        /**
         * @type {Languages}
         */
        module.exports = {
          AFR: 'afr',
          AMH: 'amh',
          ARA: 'ara',
          ASM: 'asm',
          AZE: 'aze',
          AZE_CYRL: 'aze_cyrl',
          BEL: 'bel',
          BEN: 'ben',
          BOD: 'bod',
          BOS: 'bos',
          BUL: 'bul',
          CAT: 'cat',
          CEB: 'ceb',
          CES: 'ces',
          CHI_SIM: 'chi_sim',
          CHI_TRA: 'chi_tra',
          CHR: 'chr',
          CYM: 'cym',
          DAN: 'dan',
          DEU: 'deu',
          DZO: 'dzo',
          ELL: 'ell',
          ENG: 'eng',
          ENM: 'enm',
          EPO: 'epo',
          EST: 'est',
          EUS: 'eus',
          FAS: 'fas',
          FIN: 'fin',
          FRA: 'fra',
          FRK: 'frk',
          FRM: 'frm',
          GLE: 'gle',
          GLG: 'glg',
          GRC: 'grc',
          GUJ: 'guj',
          HAT: 'hat',
          HEB: 'heb',
          HIN: 'hin',
          HRV: 'hrv',
          HUN: 'hun',
          IKU: 'iku',
          IND: 'ind',
          ISL: 'isl',
          ITA: 'ita',
          ITA_OLD: 'ita_old',
          JAV: 'jav',
          JPN: 'jpn',
          KAN: 'kan',
          KAT: 'kat',
          KAT_OLD: 'kat_old',
          KAZ: 'kaz',
          KHM: 'khm',
          KIR: 'kir',
          KOR: 'kor',
          KUR: 'kur',
          LAO: 'lao',
          LAT: 'lat',
          LAV: 'lav',
          LIT: 'lit',
          MAL: 'mal',
          MAR: 'mar',
          MKD: 'mkd',
          MLT: 'mlt',
          MSA: 'msa',
          MYA: 'mya',
          NEP: 'nep',
          NLD: 'nld',
          NOR: 'nor',
          ORI: 'ori',
          PAN: 'pan',
          POL: 'pol',
          POR: 'por',
          PUS: 'pus',
          RON: 'ron',
          RUS: 'rus',
          SAN: 'san',
          SIN: 'sin',
          SLK: 'slk',
          SLV: 'slv',
          SPA: 'spa',
          SPA_OLD: 'spa_old',
          SQI: 'sqi',
          SRP: 'srp',
          SRP_LATN: 'srp_latn',
          SWA: 'swa',
          SWE: 'swe',
          SYR: 'syr',
          TAM: 'tam',
          TEL: 'tel',
          TGK: 'tgk',
          TGL: 'tgl',
          THA: 'tha',
          TIR: 'tir',
          TUR: 'tur',
          UIG: 'uig',
          UKR: 'ukr',
          URD: 'urd',
          UZB: 'uzb',
          UZB_CYRL: 'uzb_cyrl',
          VIE: 'vie',
          YID: 'yid'
        };

        /***/
      },

    /***/ '../../node_modules/tesseract.js/src/createJob.js':
      /*!********************************************************!*\
  !*** ../../node_modules/tesseract.js/src/createJob.js ***!
  \********************************************************/
      /***/ (module, __unused_webpack_exports, __webpack_require__) => {
        'use strict';

        const getId = __webpack_require__(
          /*! ./utils/getId */ '../../node_modules/tesseract.js/src/utils/getId.js'
        );

        let jobCounter = 0;

        module.exports = ({ id: _id, action, payload = {} }) => {
          let id = _id;
          if (typeof id === 'undefined') {
            id = getId('Job', jobCounter);
            jobCounter += 1;
          }

          return {
            id,
            action,
            payload
          };
        };

        /***/
      },

    /***/ '../../node_modules/tesseract.js/src/createScheduler.js':
      /*!**************************************************************!*\
  !*** ../../node_modules/tesseract.js/src/createScheduler.js ***!
  \**************************************************************/
      /***/ function (module, __unused_webpack_exports, __webpack_require__) {
        'use strict';

        const createJob = __webpack_require__(
          /*! ./createJob */ '../../node_modules/tesseract.js/src/createJob.js'
        );
        const { log } = __webpack_require__(
          /*! ./utils/log */ '../../node_modules/tesseract.js/src/utils/log.js'
        );
        const getId = __webpack_require__(
          /*! ./utils/getId */ '../../node_modules/tesseract.js/src/utils/getId.js'
        );

        let schedulerCounter = 0;

        module.exports = () => {
          const id = getId('Scheduler', schedulerCounter);
          const workers = {};
          const runningWorkers = {};
          let jobQueue = [];

          schedulerCounter += 1;

          const getQueueLen = () => jobQueue.length;
          const getNumWorkers = () => Object.keys(workers).length;

          const dequeue = () => {
            if (jobQueue.length !== 0) {
              const wIds = Object.keys(workers);
              for (let i = 0; i < wIds.length; i += 1) {
                if (typeof runningWorkers[wIds[i]] === 'undefined') {
                  jobQueue[0](workers[wIds[i]]);
                  break;
                }
              }
            }
          };

          const queue = (action, payload) =>
            new Promise((resolve, reject) => {
              const job = createJob({ action, payload });
              jobQueue.push(async w => {
                jobQueue.shift();
                runningWorkers[w.id] = job;
                try {
                  resolve(await w[action].apply(this, [...payload, job.id]));
                } catch (err) {
                  reject(err);
                } finally {
                  delete runningWorkers[w.id];
                  dequeue();
                }
              });
              log(`[${id}]: Add ${job.id} to JobQueue`);
              log(`[${id}]: JobQueue length=${jobQueue.length}`);
              dequeue();
            });

          const addWorker = w => {
            workers[w.id] = w;
            log(`[${id}]: Add ${w.id}`);
            log(`[${id}]: Number of workers=${getNumWorkers()}`);
            dequeue();
            return w.id;
          };

          const addJob = async (action, ...payload) => {
            if (getNumWorkers() === 0) {
              throw Error(
                `[${id}]: You need to have at least one worker before adding jobs`
              );
            }
            return queue(action, payload);
          };

          const terminate = async () => {
            Object.keys(workers).forEach(async wid => {
              await workers[wid].terminate();
            });
            jobQueue = [];
          };

          return {
            addWorker,
            addJob,
            terminate,
            getQueueLen,
            getNumWorkers
          };
        };

        /***/
      },

    /***/ '../../node_modules/tesseract.js/src/createWorker.js':
      /*!***********************************************************!*\
  !*** ../../node_modules/tesseract.js/src/createWorker.js ***!
  \***********************************************************/
      /***/ (module, __unused_webpack_exports, __webpack_require__) => {
        'use strict';

        const resolvePaths = __webpack_require__(
          /*! ./utils/resolvePaths */ '../../node_modules/tesseract.js/src/utils/resolvePaths.js'
        );
        const createJob = __webpack_require__(
          /*! ./createJob */ '../../node_modules/tesseract.js/src/createJob.js'
        );
        const { log } = __webpack_require__(
          /*! ./utils/log */ '../../node_modules/tesseract.js/src/utils/log.js'
        );
        const getId = __webpack_require__(
          /*! ./utils/getId */ '../../node_modules/tesseract.js/src/utils/getId.js'
        );
        const OEM = __webpack_require__(
          /*! ./constants/OEM */ '../../node_modules/tesseract.js/src/constants/OEM.js'
        );
        const {
          defaultOptions,
          spawnWorker,
          terminateWorker,
          onMessage,
          loadImage,
          send
        } = __webpack_require__(
          /*! ./worker/node */ '../../node_modules/tesseract.js/src/worker/browser/index.js'
        );

        let workerCounter = 0;

        module.exports = async (
          langs = 'eng',
          oem = OEM.LSTM_ONLY,
          _options = {},
          config = {}
        ) => {
          const id = getId('Worker', workerCounter);
          const { logger, errorHandler, ...options } = resolvePaths({
            ...defaultOptions,
            ..._options
          });
          const promises = {};

          // Current langs, oem, and config file.
          // Used if the user ever re-initializes the worker using `worker.reinitialize`.
          const currentLangs =
            typeof langs === 'string' ? langs.split('+') : langs;
          let currentOem = oem;
          let currentConfig = config;
          const lstmOnlyCore =
            [OEM.DEFAULT, OEM.LSTM_ONLY].includes(oem) && !options.legacyCore;

          let workerResReject;
          let workerResResolve;
          const workerRes = new Promise((resolve, reject) => {
            workerResResolve = resolve;
            workerResReject = reject;
          });
          const workerError = event => {
            workerResReject(event.message);
          };

          let worker = spawnWorker(options);
          worker.onerror = workerError;

          workerCounter += 1;

          const startJob = ({ id: jobId, action, payload }) =>
            new Promise((resolve, reject) => {
              log(`[${id}]: Start ${jobId}, action=${action}`);
              // Using both `action` and `jobId` in case user provides non-unique `jobId`.
              const promiseId = `${action}-${jobId}`;
              promises[promiseId] = { resolve, reject };
              send(worker, {
                workerId: id,
                jobId,
                action,
                payload
              });
            });

          const load = () =>
            console.warn(
              '`load` is depreciated and should be removed from code (workers now come pre-loaded)'
            );

          const loadInternal = jobId =>
            startJob(
              createJob({
                id: jobId,
                action: 'load',
                payload: {
                  options: {
                    lstmOnly: lstmOnlyCore,
                    corePath: options.corePath,
                    logging: options.logging
                  }
                }
              })
            );

          const writeText = (path, text, jobId) =>
            startJob(
              createJob({
                id: jobId,
                action: 'FS',
                payload: { method: 'writeFile', args: [path, text] }
              })
            );

          const readText = (path, jobId) =>
            startJob(
              createJob({
                id: jobId,
                action: 'FS',
                payload: {
                  method: 'readFile',
                  args: [path, { encoding: 'utf8' }]
                }
              })
            );

          const removeFile = (path, jobId) =>
            startJob(
              createJob({
                id: jobId,
                action: 'FS',
                payload: { method: 'unlink', args: [path] }
              })
            );

          const FS = (method, args, jobId) =>
            startJob(
              createJob({
                id: jobId,
                action: 'FS',
                payload: { method, args }
              })
            );

          const loadLanguageInternal = (_langs, jobId) =>
            startJob(
              createJob({
                id: jobId,
                action: 'loadLanguage',
                payload: {
                  langs: _langs,
                  options: {
                    langPath: options.langPath,
                    dataPath: options.dataPath,
                    cachePath: options.cachePath,
                    cacheMethod: options.cacheMethod,
                    gzip: options.gzip,
                    lstmOnly:
                      [OEM.DEFAULT, OEM.LSTM_ONLY].includes(currentOem) &&
                      !options.legacyLang
                  }
                }
              })
            );

          const initializeInternal = (_langs, _oem, _config, jobId) =>
            startJob(
              createJob({
                id: jobId,
                action: 'initialize',
                payload: { langs: _langs, oem: _oem, config: _config }
              })
            );

          const reinitialize = (langs = 'eng', oem, config, jobId) => {
            // eslint-disable-line

            if (
              lstmOnlyCore &&
              [OEM.TESSERACT_ONLY, OEM.TESSERACT_LSTM_COMBINED].includes(oem)
            )
              throw Error('Legacy model requested but code missing.');

            const _oem = oem || currentOem;
            currentOem = _oem;

            const _config = config || currentConfig;
            currentConfig = _config;

            // Only load langs that are not already loaded.
            // This logic fails if the user downloaded the LSTM-only English data for a language
            // and then uses `worker.reinitialize` to switch to the Legacy engine.
            // However, the correct data will still be downloaded after initialization fails
            // and this can be avoided entirely if the user loads the correct data ahead of time.
            const langsArr =
              typeof langs === 'string' ? langs.split('+') : langs;
            const _langs = langsArr.filter(x => !currentLangs.includes(x));
            currentLangs.push(..._langs);

            if (_langs.length > 0) {
              return loadLanguageInternal(_langs, jobId).then(() =>
                initializeInternal(langs, _oem, _config, jobId)
              );
            }

            return initializeInternal(langs, _oem, _config, jobId);
          };

          const setParameters = (params = {}, jobId) =>
            startJob(
              createJob({
                id: jobId,
                action: 'setParameters',
                payload: { params }
              })
            );

          const recognize = async (
            image,
            opts = {},
            output = {
              text: true
            },
            jobId
          ) =>
            startJob(
              createJob({
                id: jobId,
                action: 'recognize',
                payload: {
                  image: await loadImage(image),
                  options: opts,
                  output
                }
              })
            );

          const detect = async (image, jobId) => {
            if (lstmOnlyCore)
              throw Error(
                '`worker.detect` requires Legacy model, which was not loaded.'
              );

            return startJob(
              createJob({
                id: jobId,
                action: 'detect',
                payload: { image: await loadImage(image) }
              })
            );
          };

          const terminate = async () => {
            if (worker !== null) {
              /*
      await startJob(createJob({
        id: jobId,
        action: 'terminate',
      }));
      */
              terminateWorker(worker);
              worker = null;
            }
            return Promise.resolve();
          };

          onMessage(worker, ({ workerId, jobId, status, action, data }) => {
            const promiseId = `${action}-${jobId}`;
            if (status === 'resolve') {
              log(`[${workerId}]: Complete ${jobId}`);
              promises[promiseId].resolve({ jobId, data });
              delete promises[promiseId];
            } else if (status === 'reject') {
              promises[promiseId].reject(data);
              delete promises[promiseId];
              if (action === 'load') workerResReject(data);
              if (errorHandler) {
                errorHandler(data);
              } else {
                throw Error(data);
              }
            } else if (status === 'progress') {
              logger({ ...data, userJobId: jobId });
            }
          });

          const resolveObj = {
            id,
            worker,
            load,
            writeText,
            readText,
            removeFile,
            FS,
            reinitialize,
            setParameters,
            recognize,
            detect,
            terminate
          };

          loadInternal()
            .then(() => loadLanguageInternal(langs))
            .then(() => initializeInternal(langs, oem, config))
            .then(() => workerResResolve(resolveObj))
            .catch(() => {});

          return workerRes;
        };

        /***/
      },

    /***/ '../../node_modules/tesseract.js/src/index.js':
      /*!****************************************************!*\
  !*** ../../node_modules/tesseract.js/src/index.js ***!
  \****************************************************/
      /***/ (module, __unused_webpack_exports, __webpack_require__) => {
        'use strict';

        /**
         *
         * Entry point for tesseract.js, should be the entry when bundling.
         *
         * @fileoverview entry point for tesseract.js
         * @author Kevin Kwok <antimatter15@gmail.com>
         * @author Guillermo Webster <gui@mit.edu>
         * @author Jerome Wu <jeromewus@gmail.com>
         */
        __webpack_require__(
          /*! regenerator-runtime/runtime */ '../../node_modules/regenerator-runtime/runtime.js'
        );
        const createScheduler = __webpack_require__(
          /*! ./createScheduler */ '../../node_modules/tesseract.js/src/createScheduler.js'
        );
        const createWorker = __webpack_require__(
          /*! ./createWorker */ '../../node_modules/tesseract.js/src/createWorker.js'
        );
        const Tesseract = __webpack_require__(
          /*! ./Tesseract */ '../../node_modules/tesseract.js/src/Tesseract.js'
        );
        const languages = __webpack_require__(
          /*! ./constants/languages */ '../../node_modules/tesseract.js/src/constants/languages.js'
        );
        const OEM = __webpack_require__(
          /*! ./constants/OEM */ '../../node_modules/tesseract.js/src/constants/OEM.js'
        );
        const PSM = __webpack_require__(
          /*! ./constants/PSM */ '../../node_modules/tesseract.js/src/constants/PSM.js'
        );
        const { setLogging } = __webpack_require__(
          /*! ./utils/log */ '../../node_modules/tesseract.js/src/utils/log.js'
        );

        module.exports = {
          languages,
          OEM,
          PSM,
          createScheduler,
          createWorker,
          setLogging,
          ...Tesseract
        };

        /***/
      },

    /***/ '../../node_modules/tesseract.js/src/utils/getEnvironment.js':
      /*!*******************************************************************!*\
  !*** ../../node_modules/tesseract.js/src/utils/getEnvironment.js ***!
  \*******************************************************************/
      /***/ (module, __unused_webpack_exports, __webpack_require__) => {
        'use strict';
        /* provided dependency */ var process = __webpack_require__(
          /*! process/browser */ '../../node_modules/process/browser.js'
        );

        module.exports = key => {
          const env = {};

          if (typeof WorkerGlobalScope !== 'undefined') {
            env.type = 'webworker';
          } else if (typeof document === 'object') {
            env.type = 'browser';
          } else if (typeof process === 'object' && 'function' === 'function') {
            env.type = 'node';
          }

          if (typeof key === 'undefined') {
            return env;
          }

          return env[key];
        };

        /***/
      },

    /***/ '../../node_modules/tesseract.js/src/utils/getId.js':
      /*!**********************************************************!*\
  !*** ../../node_modules/tesseract.js/src/utils/getId.js ***!
  \**********************************************************/
      /***/ module => {
        'use strict';

        module.exports = (prefix, cnt) =>
          `${prefix}-${cnt}-${Math.random().toString(16).slice(3, 8)}`;

        /***/
      },

    /***/ '../../node_modules/tesseract.js/src/utils/log.js':
      /*!********************************************************!*\
  !*** ../../node_modules/tesseract.js/src/utils/log.js ***!
  \********************************************************/
      /***/ function (__unused_webpack_module, exports) {
        'use strict';

        let logging = false;

        exports.logging = logging;

        exports.setLogging = _logging => {
          logging = _logging;
        };

        exports.log = (...args) =>
          logging ? console.log.apply(this, args) : null;

        /***/
      },

    /***/ '../../node_modules/tesseract.js/src/utils/resolvePaths.js':
      /*!*****************************************************************!*\
  !*** ../../node_modules/tesseract.js/src/utils/resolvePaths.js ***!
  \*****************************************************************/
      /***/ (module, __unused_webpack_exports, __webpack_require__) => {
        'use strict';

        const isBrowser =
          __webpack_require__(
            /*! ./getEnvironment */ '../../node_modules/tesseract.js/src/utils/getEnvironment.js'
          )('type') === 'browser';

        const resolveURL = isBrowser
          ? s => new URL(s, window.location.href).href
          : s => s; // eslint-disable-line

        module.exports = options => {
          const opts = { ...options };
          ['corePath', 'workerPath', 'langPath'].forEach(key => {
            if (options[key]) {
              opts[key] = resolveURL(opts[key]);
            }
          });
          return opts;
        };

        /***/
      },

    /***/ '../../node_modules/tesseract.js/src/worker/browser/defaultOptions.js':
      /*!****************************************************************************!*\
  !*** ../../node_modules/tesseract.js/src/worker/browser/defaultOptions.js ***!
  \****************************************************************************/
      /***/ (module, __unused_webpack_exports, __webpack_require__) => {
        'use strict';

        const version = __webpack_require__(
          /*! ../../../package.json */ '../../node_modules/tesseract.js/package.json'
        ).version;
        const defaultOptions = __webpack_require__(
          /*! ../../constants/defaultOptions */ '../../node_modules/tesseract.js/src/constants/defaultOptions.js'
        );

        /*
         * Default options for browser worker
         */
        module.exports = {
          ...defaultOptions,
          workerPath: `https://cdn.jsdelivr.net/npm/tesseract.js@v${version}/dist/worker.min.js`
        };

        /***/
      },

    /***/ '../../node_modules/tesseract.js/src/worker/browser/index.js':
      /*!*******************************************************************!*\
  !*** ../../node_modules/tesseract.js/src/worker/browser/index.js ***!
  \*******************************************************************/
      /***/ (module, __unused_webpack_exports, __webpack_require__) => {
        'use strict';

        /**
         *
         * Tesseract Worker adapter for browser
         *
         * @fileoverview Tesseract Worker adapter for browser
         * @author Kevin Kwok <antimatter15@gmail.com>
         * @author Guillermo Webster <gui@mit.edu>
         * @author Jerome Wu <jeromewus@gmail.com>
         */
        const defaultOptions = __webpack_require__(
          /*! ./defaultOptions */ '../../node_modules/tesseract.js/src/worker/browser/defaultOptions.js'
        );
        const spawnWorker = __webpack_require__(
          /*! ./spawnWorker */ '../../node_modules/tesseract.js/src/worker/browser/spawnWorker.js'
        );
        const terminateWorker = __webpack_require__(
          /*! ./terminateWorker */ '../../node_modules/tesseract.js/src/worker/browser/terminateWorker.js'
        );
        const onMessage = __webpack_require__(
          /*! ./onMessage */ '../../node_modules/tesseract.js/src/worker/browser/onMessage.js'
        );
        const send = __webpack_require__(
          /*! ./send */ '../../node_modules/tesseract.js/src/worker/browser/send.js'
        );
        const loadImage = __webpack_require__(
          /*! ./loadImage */ '../../node_modules/tesseract.js/src/worker/browser/loadImage.js'
        );

        module.exports = {
          defaultOptions,
          spawnWorker,
          terminateWorker,
          onMessage,
          send,
          loadImage
        };

        /***/
      },

    /***/ '../../node_modules/tesseract.js/src/worker/browser/loadImage.js':
      /*!***********************************************************************!*\
  !*** ../../node_modules/tesseract.js/src/worker/browser/loadImage.js ***!
  \***********************************************************************/
      /***/ module => {
        'use strict';

        /**
         * readFromBlobOrFile
         *
         * @name readFromBlobOrFile
         * @function
         * @access private
         */
        const readFromBlobOrFile = blob =>
          new Promise((resolve, reject) => {
            const fileReader = new FileReader();
            fileReader.onload = () => {
              resolve(fileReader.result);
            };
            fileReader.onerror = ({
              target: {
                error: { code }
              }
            }) => {
              reject(Error(`File could not be read! Code=${code}`));
            };
            fileReader.readAsArrayBuffer(blob);
          });

        /**
         * loadImage
         *
         * @name loadImage
         * @function load image from different source
         * @access private
         */
        const loadImage = async image => {
          let data = image;
          if (typeof image === 'undefined') {
            return 'undefined';
          }

          if (typeof image === 'string') {
            // Base64 Image
            if (/data:image\/([a-zA-Z]*);base64,([^"]*)/.test(image)) {
              data = atob(image.split(',')[1])
                .split('')
                .map(c => c.charCodeAt(0));
            } else {
              const resp = await fetch(image);
              data = await resp.arrayBuffer();
            }
          } else if (
            typeof HTMLElement !== 'undefined' &&
            image instanceof HTMLElement
          ) {
            if (image.tagName === 'IMG') {
              data = await loadImage(image.src);
            }
            if (image.tagName === 'VIDEO') {
              data = await loadImage(image.poster);
            }
            if (image.tagName === 'CANVAS') {
              await new Promise(resolve => {
                image.toBlob(async blob => {
                  data = await readFromBlobOrFile(blob);
                  resolve();
                });
              });
            }
          } else if (
            typeof OffscreenCanvas !== 'undefined' &&
            image instanceof OffscreenCanvas
          ) {
            const blob = await image.convertToBlob();
            data = await readFromBlobOrFile(blob);
          } else if (image instanceof File || image instanceof Blob) {
            data = await readFromBlobOrFile(image);
          }

          return new Uint8Array(data);
        };

        module.exports = loadImage;

        /***/
      },

    /***/ '../../node_modules/tesseract.js/src/worker/browser/onMessage.js':
      /*!***********************************************************************!*\
  !*** ../../node_modules/tesseract.js/src/worker/browser/onMessage.js ***!
  \***********************************************************************/
      /***/ module => {
        'use strict';

        module.exports = (worker, handler) => {
          worker.onmessage = ({ data }) => {
            // eslint-disable-line
            handler(data);
          };
        };

        /***/
      },

    /***/ '../../node_modules/tesseract.js/src/worker/browser/send.js':
      /*!******************************************************************!*\
  !*** ../../node_modules/tesseract.js/src/worker/browser/send.js ***!
  \******************************************************************/
      /***/ module => {
        'use strict';

        /**
         * send
         *
         * @name send
         * @function send packet to worker and create a job
         * @access public
         */
        module.exports = async (worker, packet) => {
          worker.postMessage(packet);
        };

        /***/
      },

    /***/ '../../node_modules/tesseract.js/src/worker/browser/spawnWorker.js':
      /*!*************************************************************************!*\
  !*** ../../node_modules/tesseract.js/src/worker/browser/spawnWorker.js ***!
  \*************************************************************************/
      /***/ module => {
        'use strict';

        /**
         * spawnWorker
         *
         * @name spawnWorker
         * @function create a new Worker in browser
         * @access public
         */
        module.exports = ({ workerPath, workerBlobURL }) => {
          let worker;
          if (Blob && URL && workerBlobURL) {
            const blob = new Blob([`importScripts("${workerPath}");`], {
              type: 'application/javascript'
            });
            worker = new Worker(URL.createObjectURL(blob));
          } else {
            worker = new Worker(workerPath);
          }

          return worker;
        };

        /***/
      },

    /***/ '../../node_modules/tesseract.js/src/worker/browser/terminateWorker.js':
      /*!*****************************************************************************!*\
  !*** ../../node_modules/tesseract.js/src/worker/browser/terminateWorker.js ***!
  \*****************************************************************************/
      /***/ module => {
        'use strict';

        /**
         * terminateWorker
         *
         * @name terminateWorker
         * @function terminate worker
         * @access public
         */
        module.exports = worker => {
          worker.terminate();
        };

        /***/
      }
  }
]);
//# sourceMappingURL=vendors-node_modules_axios_lib_axios_js-node_modules_marked_lib_marked_esm_js-node_modules_te-216543.7cefc77454b9795320c1.js.map
